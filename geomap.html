<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <title>Peta MapLibre — GPX/GeoJSON Upload & Layer Editor (Fixed polygons)</title>

  <!-- MapLibre GL JS -->
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

  <!-- toGeoJSON (konversi GPX -> GeoJSON) -->
  <script src="https://unpkg.com/@mapbox/togeojson@0.16.2/togeojson.js"></script>

  <style>
    html,body,#map { height: 100%; margin: 0; padding: 0; font-family: Inter, Arial, sans-serif; }
    #app { display: grid; grid-template-columns: 380px 1fr; height: 100vh; }
    #sidebar { background:#fff; border-right:1px solid #e6e6e6; padding:12px; box-sizing:border-box; overflow:auto;}
    h2 { margin:6px 0 12px; font-size:18px; }
    .control { margin-bottom:12px; }
    #map { position: relative; }

    .layer-item { display:flex;align-items:center;justify-content:space-between;padding:8px;border:1px solid #eee;border-radius:6px;margin-bottom:6px;}
    .layer-left { display:flex; gap:8px; align-items:center;}
    .btn { background:#2b6cb0;color:#fff;padding:6px 8px;border-radius:6px;border:none;cursor:pointer;}
    .btn.secondary { background:#edf2f7;color:#111; }
    .btn.warn { background:#d9534f; }
    input[type=file] { display:block; margin-top:8px; }
    .small { font-size:12px;color:#666; }
    label { display:block; margin-bottom:6px; font-weight:600; }

    /* Modal */
    .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.4); display:none; align-items:center; justify-content:center; z-index:9999;}
    .modal { background:#fff; width:440px; border-radius:8px; padding:16px; box-shadow:0 8px 24px rgba(0,0,0,0.2); }
    .modal h3 { margin:0 0 8px; font-size:16px; }
    .form-row { margin:8px 0; display:flex; align-items:center; gap:8px; justify-content:space-between; }
    .form-row input[type="range"] { width:200px; }
    .legend { margin-top:12px; border-top:1px solid #eee; padding-top:8px; font-size:13px; }
    .basemap-select { width:100%; padding:6px; border-radius:6px; border:1px solid #ddd; }
    .layer-actions { display:flex; gap:6px; }
    .muted { color:#666; font-size:12px; }
  </style>

  <style>
  /* overlay helper (not rendered into canvas directly) */
  #printMapBtn { margin-top:8px; display:block; }
  .grid-label { position:absolute; background:rgba(255,255,255,0.8); padding:2px 4px; font-size:11px; border-radius:2px; pointer-events:none; }
  </style>
</head>
<body>
  <div id="app">
    <aside id="sidebar">
      <h2>Peta — ArcGIS-like (MapLibre)</h2>

      <div class="control">
        <label>Basemap</label>
        <select id="basemapSelect" class="basemap-select">
          <option value="osm">OpenStreetMap</option>
          <option value="terrain">Terrain (Stamen Terrain)</option>
          <option value="satellite">Satellite (Esri.WorldImagery)</option>
          <option value="light">Light (Carto)</option>
          <option value="dark">Dark (Carto)</option>
        </select>
      </div>

      <div class="control">
        <label>Upload file (GPX or GeoJSON)</label>
        <input id="fileInput" type="file" accept=".gpx,.xml,.geojson,.json" />
        <div style="margin-top:8px;">
          <button id="uploadToDrive" class="btn">Upload → Google Drive</button>
          <button id="addLocal" class="btn secondary">Load locally (tanpa upload)</button>
          <button id="loadUploadedGPX" class="btn secondary" title="Load GPX yang sudah diupload di session ini">Load: Rangkum Langkimat.gpx</button>
        </div>
        <div id="uploadStatus" class="small" style="margin-top:8px;"></div>
      </div>

      <div class="control">
        <label>Rendering & Convert options</label>
        <input type="checkbox" id="treatTrackAsPolygon" /> <label for="treatTrackAsPolygon" style="display:inline;font-weight:normal">Treat closed tracks as polygon</label><br>
        <input type="checkbox" id="simplifyOnConvert" /> <label for="simplifyOnConvert" style="display:inline;font-weight:normal">Simplify converted polygons</label><br>
        <label class="muted">Simplify tolerance (m) — higher = more simplification</label>
        <input id="simplifyTolerance" type="range" min="0" max="50" step="1" value="5" />
        <div class="muted">Auto zoom to uploaded data <input type="checkbox" id="autoZoom" checked style="margin-left:8px"/></div>
      </div>

      <div class="control">
        <label>Layers</label>
        <div id="layerList"></div>
      </div>

      <div class="control">
        <label>Export</label>
        <div style="display:flex; gap:8px;">
          <button id="exportGeoJSON" class="btn secondary">Export All GeoJSON</button>
          <button id="exportState" class="btn secondary">Download State</button>
        </div>
      </div>

      <div class="small legend" id="legend">
        <b>Legend:</b>
        <div id="legendItems"></div>
      </div>
    </aside>

    <div id="map"></div>
  </div>

  <!-- STYLE EDITOR MODAL -->
  <div id="modalBackdrop" class="modal-backdrop" role="dialog" aria-hidden="true">
    <div class="modal" role="document">
      <h3 id="modalTitle">Edit Layer</h3>
      <div id="modalBody">
        <div class="form-row"><label>Color</label><input type="color" id="styleColor" /></div>
        <div class="form-row" id="lineOptions"><label>Line width</label><input id="lineWidth" type="range" min="1" max="12" value="3" /></div>
        <div class="form-row" id="radiusOptions" style="display:none"><label>Radius</label><input id="pointRadius" type="range" min="1" max="20" value="6" /></div>
        <div class="form-row"><label>Opacity</label><input id="styleOpacity" type="range" min="0" max="1" step="0.05" value="1" /></div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px;">
          <button id="modalCancel" class="btn secondary">Cancel</button>
          <button id="modalSave" class="btn">Save</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ====== CONFIG ====== */
    const APPS_SCRIPT_URL = 'REPLACE_WITH_YOUR_APPS_SCRIPT_URL';
    const UPLOADED_GPX_PATH = '/mnt/data/Rangkum Langkimat.gpx';

    const DEFAULT_STYLE = {
      trackLine: '#d35400',
      trackLineOutline: '#8e2b00',
      waypoint: '#1f78b4',
      polygonFill: '#f6e6d8',
      polygonOutline: '#d98b3a'
    };

    /* ====== Map & basemap helpers ====== */
    const basemapDefs = {
      osm: { tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'], attribution: '© OpenStreetMap contributors' },
      terrain: { tiles: ['https://stamen-tiles.a.ssl.fastly.net/terrain/{z}/{x}/{y}.jpg'], attribution: 'Terrain tiles by Stamen' },
      satellite: { tiles: ['https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'], attribution: 'Esri World Imagery' },
      light: { tiles: ['https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png'], attribution: 'Carto Light' },
      dark: { tiles: ['https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png'], attribution: 'Carto Dark' }
    };

    const map = new maplibregl.Map({
      container: 'map',
      style: {...},
      center: [101.45, -0.45],
      zoom: 11
    });
    window.map = map;   // ← FIX WAJIB

    map.addControl(new maplibregl.NavigationControl(), 'top-right');
    map.addControl(new maplibregl.ScaleControl({maxWidth:200, unit:'metric'}), 'bottom-right');

    /* ====== State ====== */
    const state = { layers: [], nextId: 1 };

    /* ====== Ramer–Douglas–Peucker (2D simplification) ====== */
    // Works on arrays of [lng,lat]; tolerance in meters — will convert to degrees approx using lat correction.
    function simplifyRDP(coords, toleranceMeters) {
      if (!coords || coords.length < 3) return coords.slice();
      // approximate meter -> degree at given latitude (use mean latitude)
      const meanLat = coords.reduce((s,c)=>s + c[1],0)/coords.length;
      const meterToDeg = 1 / (111320 * Math.cos(meanLat * Math.PI/180)); // approx degrees per meter
      const tol = toleranceMeters * meterToDeg;

      function sqDist(p1,p2) { const dx = p1[0]-p2[0], dy = p1[1]-p2[1]; return dx*dx + dy*dy; }
      function distToSegmentSquared(p, v, w) {
        const l2 = sqDist(v,w);
        if (l2 === 0) return sqDist(p,v);
        let t = ((p[0]-v[0])*(w[0]-v[0]) + (p[1]-v[1])*(w[1]-v[1]))/l2;
        t = Math.max(0, Math.min(1,t));
        const proj = [ v[0] + t*(w[0]-v[0]), v[1] + t*(w[1]-v[1]) ];
        return sqDist(p, proj);
      }
      function rdp(points, eps) {
        const n = points.length;
        const keep = new Array(n).fill(false);
        keep[0] = keep[n-1] = true;
        const stack = [[0, n-1]];
        while (stack.length) {
          const [i,j] = stack.pop();
          let maxDist = 0, idx = -1;
          for (let k=i+1;k<j;k++) {
            const d = distToSegmentSquared(points[k], points[i], points[j]);
            if (d > maxDist) { maxDist = d; idx = k; }
          }
          if (Math.sqrt(maxDist) > eps) {
            keep[idx] = true;
            stack.push([i, idx]);
            stack.push([idx, j]);
          }
        }
        const res = [];
        for (let i=0;i<n;i++) if (keep[i]) res.push(points[i]);
        return res;
      }
      return rdp(coords, tol);
    }

    /* ====== Core: add layer to map ====== */
    function addLayerToMap(layerObj) {
      const id = 'layer-' + layerObj.id;
      // remove existing source/layers to update cleanly
      const suffixes = ['-outline','-line','-symbol','-fill'];
      suffixes.forEach(s => { const lid = id + s; if (map.getLayer(lid)) try { map.removeLayer(lid); } catch(e){} });
      if (map.getSource(id)) try { map.removeSource(id); } catch(e){}

      map.addSource(id, { type: 'geojson', data: layerObj.geojson });

      // style defaults
      const style = layerObj.style = layerObj.style || {};
      if (layerObj.type === 'track') {
        // outline
        map.addLayer({
          id: id + '-outline',
          type: 'line',
          source: id,
          layout: { 'line-join': 'round', 'line-cap': 'round' },
          paint: {
            'line-color': style.outlineColor || style.color || DEFAULT_STYLE.trackLineOutline,
            'line-width': style.outlineWidth || (style.width ? Math.max(3, style.width+2) : 6),
            'line-opacity': typeof style.opacity === 'number' ? style.opacity : 0.9
          },
          filter: ["in", ["geometry-type"], ["literal", ["LineString", "MultiLineString"]]]
        });
        // main line
        map.addLayer({
          id: id + '-line',
          type: 'line',
          source: id,
          layout: { 'line-join': 'round', 'line-cap': 'round' },
          paint: {
            'line-color': style.color || DEFAULT_STYLE.trackLine,
            'line-width': style.width || 3,
            'line-opacity': typeof style.opacity === 'number' ? style.opacity : 1.0
          },
          filter: ["in", ["geometry-type"], ["literal", ["LineString", "MultiLineString"]]]
        });
      } else if (layerObj.type === 'point') {
        map.addLayer({
          id: id + '-symbol',
          type: 'circle',
          source: id,
          paint: {
            'circle-radius': layerObj.style && layerObj.style.radius ? layerObj.style.radius : 6,
            'circle-color': layerObj.style && layerObj.style.color ? layerObj.style.color : DEFAULT_STYLE.waypoint,
            'circle-stroke-color': '#fff',
            'circle-stroke-width': 1,
            'circle-opacity': typeof layerObj.style && layerObj.style.opacity === 'number' ? layerObj.style.opacity : 1
          },
          filter: ["==", ["geometry-type"], "Point"]
        });
      } else if (layerObj.type === 'polygon') {
        map.addLayer({
          id: id + '-fill',
          type: 'fill',
          source: id,
          paint: {
            'fill-color': layerObj.style && layerObj.style.color ? layerObj.style.color : DEFAULT_STYLE.polygonFill,
            'fill-opacity': typeof layerObj.style && layerObj.style.opacity === 'number' ? layerObj.style.opacity : 0.6
          }
        });
        map.addLayer({
          id: id + '-outline',
          type: 'line',
          source: id,
          paint: {
            'line-color': layerObj.style && layerObj.style.outlineColor ? layerObj.style.outlineColor : DEFAULT_STYLE.polygonOutline,
            'line-width': layerObj.style && layerObj.style.outlineWidth ? layerObj.style.outlineWidth : 2
          }
        });
      }

      toggleLayerVisibility(layerObj);
      addClickHandlersForLayer(layerObj);
    }

    function addClickHandlersForLayer(layerObj) {
      const base = 'layer-' + layerObj.id;
      const symbolId = base + '-symbol';
      const lineId = base + '-line';
      if (map.getLayer(symbolId)) {
        map.off('click', symbolId, handleFeatureClick);
        map.on('click', symbolId, handleFeatureClick);
      }
      if (map.getLayer(lineId)) {
        map.off('click', lineId, handleFeatureClick);
        map.on('click', lineId, handleFeatureClick);
      }
    }

    function handleFeatureClick(e) {
      const props = e.features && e.features[0] && e.features[0].properties ? e.features[0].properties : {};
      new maplibregl.Popup()
        .setLngLat(e.lngLat)
        .setHTML('<pre style="font-size:12px">' + JSON.stringify(props, null, 2) + '</pre>')
        .addTo(map);
    }

    /* ====== UI & state helpers ====== */
    function refreshLayerList() {
      const list = document.getElementById('layerList');
      list.innerHTML = '';
      state.layers.slice().reverse().forEach(layer => {
        const el = document.createElement('div'); el.className='layer-item';
        const left = document.createElement('div'); left.className='layer-left';
        const cb = document.createElement('input'); cb.type='checkbox'; cb.checked = layer.visible; cb.dataset.id = layer.id;
        cb.onchange = () => { layer.visible = cb.checked; toggleLayerVisibility(layer); refreshLegend(); };
        const title = document.createElement('div'); title.innerHTML = `<b>${layer.name}</b><div class="small">${layer.type}</div>`;
        left.appendChild(cb); left.appendChild(title);

        const right = document.createElement('div'); right.className='layer-actions';
        const btnStyle = document.createElement('button'); btnStyle.className='btn secondary'; btnStyle.textContent='Style'; btnStyle.onclick = () => openStyleModal(layer.id);
        const btnUp = document.createElement('button'); btnUp.className='btn'; btnUp.textContent='▲'; btnUp.title='Move up'; btnUp.onclick = () => moveLayer(layer.id, -1);
        const btnDown = document.createElement('button'); btnDown.className='btn'; btnDown.textContent='▼'; btnDown.title='Move down'; btnDown.onclick = () => moveLayer(layer.id, 1);
        const btnZoom = document.createElement('button'); btnZoom.className='btn secondary'; btnZoom.textContent='Zoom'; btnZoom.onclick = () => zoomToGeoJSON(layer.geojson);
        const btnExport = document.createElement('button'); btnExport.className='btn secondary'; btnExport.textContent='Export'; btnExport.onclick = () => exportLayerGeoJSON(layer);
        const btnConvert = document.createElement('button'); btnConvert.className='btn secondary'; btnConvert.textContent='Convert'; btnConvert.title='Convert track→polygon if closed'; btnConvert.onclick = () => convertTrackToPolygon(layer.id);
        const btnRemove = document.createElement('button'); btnRemove.className='btn warn'; btnRemove.textContent='Remove'; btnRemove.onclick = () => { removeLayer(layer.id); };

        right.appendChild(btnStyle);
        right.appendChild(btnUp);
        right.appendChild(btnDown);
        right.appendChild(btnZoom);
        right.appendChild(btnExport);
        right.appendChild(btnConvert);
        right.appendChild(btnRemove);

        el.appendChild(left); el.appendChild(right);
        list.appendChild(el);
      });
    }

    function refreshLegend(){
      const node = document.getElementById('legendItems');
      node.innerHTML = '';
      state.layers.forEach(l => {
        const div = document.createElement('div');
        const sample = document.createElement('span');
        sample.style.display='inline-block'; sample.style.width='18px'; sample.style.height='12px'; sample.style.marginRight='8px';
        const color = (l.style && l.style.color) || (l.type === 'track' ? DEFAULT_STYLE.trackLine : l.type==='point' ? DEFAULT_STYLE.waypoint : DEFAULT_STYLE.polygonFill);
        sample.style.background = color;
        div.innerHTML = `<b>${l.name}</b> <span class="small">(${l.type})</span>`;
        div.prepend(sample);
        node.appendChild(div);
      });
    }

    function toggleLayerVisibility(layer) {
      const id = 'layer-' + layer.id;
      const visible = layer.visible;
      const suffixes = ['-outline','-line','-symbol','-fill'];
      suffixes.forEach(s => {
        const lid = id + s;
        if (map.getLayer(lid)) {
          map.setLayoutProperty(lid, 'visibility', visible ? 'visible' : 'none');
        }
      });
    }

    function moveLayer(id, delta) {
      const idx = state.layers.findIndex(l => l.id === id);
      if (idx === -1) return;
      const newIdx = idx + delta;
      if (newIdx < 0 || newIdx >= state.layers.length) return;
      [state.layers[idx], state.layers[newIdx]] = [state.layers[newIdx], state.layers[idx]];
      rebuildAllLayers();
    }

    function removeLayer(id) {
      const idx = state.layers.findIndex(l => l.id === id);
      if (idx === -1) return;
      const base = 'layer-' + id;
      ['-outline','-line','-symbol','-fill'].forEach(s => {
        const lid = base + s;
        if (map.getLayer(lid)) try { map.removeLayer(lid); } catch(e){}
      });
      if (map.getSource(base)) try { map.removeSource(base); } catch(e){}
      state.layers.splice(idx,1);
      refreshLayerList(); refreshLegend();
    }

    function rebuildAllLayers() {
      // remove app layers
      const suffixes = ['-outline','-line','-symbol','-fill'];
      state.layers.forEach(l => {
        const base = 'layer-' + l.id;
        suffixes.forEach(s => { const lid = base + s; if (map.getLayer(lid)) try { map.removeLayer(lid); } catch(e){} });
        if (map.getSource(base)) try { map.removeSource(base); } catch(e){}
      });
      // re-add in order
      state.layers.forEach(l => addLayerToMap(l));
      refreshLayerList(); refreshLegend();
    }

    function zoomToGeoJSON(geojson) {
      if (!geojson || !geojson.features || geojson.features.length===0) return;
      const coords = [];
      geojson.features.forEach(f => {
        const geom = f.geometry; if (!geom) return;
        if (geom.type === 'Point') coords.push(geom.coordinates);
        else if (geom.type === 'LineString') coords.push(...geom.coordinates);
        else if (geom.type === 'MultiLineString') geom.coordinates.forEach(a => coords.push(...a));
        else if (geom.type === 'Polygon') geom.coordinates.flat().forEach(c=>coords.push(c));
        else if (geom.type === 'MultiPolygon') geom.coordinates.flat(2).forEach(c=>coords.push(c));
      });
      if (coords.length === 0) return;
      const lats = coords.map(c => c[1]); const lngs = coords.map(c => c[0]);
      map.fitBounds([[Math.min(...lngs), Math.min(...lats)], [Math.max(...lngs), Math.max(...lats)]], {padding:40});
    }

    /* ====== File handling & parsing ====== */
    document.getElementById('addLocal').onclick = async () => {
      const input = document.getElementById('fileInput');
      if (!input.files || input.files.length === 0) { alert('Pilih file dulu'); return; }
      const file = input.files[0];
      await handleFileRead(file);
    };

    document.getElementById('uploadToDrive').onclick = async () => {
      const input = document.getElementById('fileInput');
      if (!input.files || input.files.length === 0) { alert('Pilih file dulu'); return; }
      document.getElementById('uploadStatus').textContent = 'Uploading...';
      const file = input.files[0];
      try {
        const res = await uploadToAppsScript(file);
        document.getElementById('uploadStatus').textContent = 'Uploaded: ' + res.name;
        const contentResp = await fetch(res.url);
        const text = await contentResp.text();
        await parseAndAddFileContent(text, file.name);
      } catch (err) {
        document.getElementById('uploadStatus').textContent = 'Error: ' + err.message;
      }
    };

    document.getElementById('loadUploadedGPX').onclick = async () => {
      try {
        const resp = await fetch(UPLOADED_GPX_PATH);
        if (!resp.ok) throw new Error('Fetch failed: ' + resp.status);
        const text = await resp.text();
        await parseAndAddFileContent(text, 'Rangkum Langkimat.gpx');
      } catch (err) {
        alert('Gagal load uploaded GPX: ' + err.message + '\n(If running locally, ensure your environment serves that path.)');
      }
    };

    async function uploadToAppsScript(file) {
      const form = new FormData();
      form.append('filename', file.name);
      form.append('contentType', file.type || 'application/octet-stream');
      const arr = await file.arrayBuffer();
      const b64 = arrayBufferToBase64(arr);
      form.append('b64', b64);
      const resp = await fetch(APPS_SCRIPT_URL, { method: 'POST', body: form });
      if (!resp.ok) throw new Error('Upload failed: ' + resp.status);
      const j = await resp.json();
      if (j.error) throw new Error(j.error);
      return j;
    }

    function arrayBufferToBase64(buffer) {
      let binary = '';
      const bytes = new Uint8Array(buffer);
      const len = bytes.byteLength;
      for (let i = 0; i < len; i++) binary += String.fromCharCode(bytes[i]);
      return btoa(binary);
    }

    async function handleFileRead(file) {
      const text = await file.text();
      await parseAndAddFileContent(text, file.name);
    }

    async function parseAndAddFileContent(text, filename) {
      const name = filename.toLowerCase();
      let geojson = null;
      if (name.endsWith('.gpx') || text.trim().startsWith('<?xml')) {
        const parser = new DOMParser();
        const xml = parser.parseFromString(text, 'application/xml');
        geojson = toGeoJSON.gpx(xml);
      } else if (name.endsWith('.geojson') || name.endsWith('.json')) {
        geojson = JSON.parse(text);
      } else {
        alert('Unsupported file type. Use GPX or GeoJSON.');
        return;
      }

      // Split into feature collections
      const points = {type:'FeatureCollection', features: []};
      const lines = {type:'FeatureCollection', features: []};
      const polygons = {type:'FeatureCollection', features: []};

      geojson.features.forEach(f => {
        if (!f.geometry) return;
        const t = f.geometry.type;
        if (t === 'Point' || t === 'MultiPoint') points.features.push(f);
        else if (t === 'LineString' || t === 'MultiLineString') {
          const treatAsPoly = document.getElementById('treatTrackAsPolygon').checked;
          if (treatAsPoly && t === 'LineString') {
            const coords = f.geometry.coordinates;
            if (coords.length >= 3) {
              // only convert if closes (with tolerance)
              if (isRingClosed(coords)) {
                const ring = closeRing(coords);
                polygons.features.push({type:'Feature', properties: f.properties||{}, geometry: { type: 'Polygon', coordinates: [ring] }});
                return;
              }
            }
          }
          lines.features.push(f);
        } else if (t === 'Polygon' || t === 'MultiPolygon') polygons.features.push(f);
      });

      // Add layers to state
      if (lines.features.length) addNewLayer(lines, 'track', filename + ' — tracks');
      if (points.features.length) addNewLayer(points, 'point', filename + ' — waypoints');
      if (polygons.features.length) addNewLayer(polygons, 'polygon', filename + ' — polygons');

      refreshLayerList(); refreshLegend();
      if (document.getElementById('autoZoom').checked) {
        const combined = {type:'FeatureCollection', features: []};
        combined.features.push(...lines.features, ...points.features, ...polygons.features);
        zoomToGeoJSON(combined);
      }
    }

    function isRingClosed(coords, tolerance=0) {
      if (!coords || coords.length < 3) return false;
      const a = coords[0], b = coords[coords.length-1];
      // exact equality or within tiny tolerance
      if (Math.abs(a[0]-b[0]) <= tolerance && Math.abs(a[1]-b[1]) <= tolerance) return true;
      return false;
    }

    function closeRing(coords) {
      const ring = coords.slice();
      const a = ring[0], b = ring[ring.length-1];
      if (a[0] !== b[0] || a[1] !== b[1]) ring.push([a[0], a[1]]);
      return ring;
    }

    function addNewLayer(geojson, type, name) {
      const layer = {
        id: state.nextId++,
        name,
        type,
        geojson,
        visible: true,
        style: {
          color: type==='track' ? DEFAULT_STYLE.trackLine : type==='point' ? DEFAULT_STYLE.waypoint : DEFAULT_STYLE.polygonFill,
          width: type==='track' ? 3 : undefined,
          opacity: 1,
          radius: type==='point' ? 6 : undefined
        }
      };
      state.layers.push(layer);
      addLayerToMap(layer);
      refreshLayerList(); refreshLegend();
    }

    /* ====== Convert track -> polygon with fixes and optional simplify ====== */
    function convertTrackToPolygon(layerId) {
      const layer = state.layers.find(l => l.id === layerId);
      if (!layer || layer.type !== 'track') { alert('Layer bukan track'); return; }
      const simplify = document.getElementById('simplifyOnConvert').checked;
      const tolMeters = parseFloat(document.getElementById('simplifyTolerance').value || '0');

      const polygons = { type:'FeatureCollection', features: [] };
      layer.geojson.features.forEach(f => {
        const g = f.geometry; if (!g) return;
        if (g.type === 'LineString') {
          let coords = g.coordinates.slice();
          if (!isRingClosed(coords)) coords = closeRing(coords);
          if (coords.length >= 4) { // polygon needs at least 4 coords (first==last)
            if (simplify && tolMeters > 0) coords = simplifyRDP(coords, tolMeters);
            // ensure still closed after simplify
            if (!isRingClosed(coords)) coords.push([coords[0][0], coords[0][1]]);
            if (coords.length >= 4) polygons.features.push({ type:'Feature', properties: f.properties || {}, geometry: { type: 'Polygon', coordinates: [coords] } });
          }
        } else if (g.type === 'MultiLineString') {
          g.coordinates.forEach(arr => {
            let coords = arr.slice();
            if (!isRingClosed(coords)) coords = closeRing(coords);
            if (coords.length >= 4) {
              if (simplify && tolMeters > 0) coords = simplifyRDP(coords, tolMeters);
              if (!isRingClosed(coords)) coords.push([coords[0][0], coords[0][1]]);
              if (coords.length >= 4) polygons.features.push({ type:'Feature', properties: f.properties || {}, geometry: { type: 'Polygon', coordinates: [coords] } });
            }
          });
        }
      });

      if (polygons.features.length === 0) { alert('Tidak ada track tertutup untuk dikonversi (atau setelah simplifikasi tidak valid).'); return; }
      addNewLayer(polygons, 'polygon', layer.name + ' — converted polygons');
    }

    /* ====== Modal style editor (option C) ====== */
    const modalBackdrop = document.getElementById('modalBackdrop');
    const styleColor = document.getElementById('styleColor');
    const styleOpacity = document.getElementById('styleOpacity');
    const lineWidth = document.getElementById('lineWidth');
    const pointRadius = document.getElementById('pointRadius');
    let editingLayerId = null;

    function openStyleModal(layerId) {
      const layer = state.layers.find(l => l.id === layerId);
      if (!layer) return;
      editingLayerId = layerId;
      document.getElementById('modalTitle').textContent = 'Edit: ' + layer.name;
      styleColor.value = (layer.style && layer.style.color) ? rgbToHex(layer.style.color) : '#ff0000';
      styleOpacity.value = (typeof layer.style.opacity === 'number') ? layer.style.opacity : 1;
      lineWidth.value = (layer.style && layer.style.width) ? layer.style.width : 3;
      pointRadius.value = (layer.style && layer.style.radius) ? layer.style.radius : 6;
      document.getElementById('lineOptions').style.display = layer.type==='track' || layer.type==='polygon' ? 'flex' : 'none';
      document.getElementById('radiusOptions').style.display = layer.type==='point' ? 'flex' : 'none';
      modalBackdrop.style.display = 'flex'; modalBackdrop.setAttribute('aria-hidden','false');
    }

    document.getElementById('modalCancel').onclick = () => {
      modalBackdrop.style.display = 'none'; modalBackdrop.setAttribute('aria-hidden','true'); editingLayerId = null;
    };

    document.getElementById('modalSave').onclick = () => {
      if (!editingLayerId) return;
      const layer = state.layers.find(l => l.id === editingLayerId);
      if (!layer) return;
      layer.style = layer.style || {};
      layer.style.color = styleColor.value;
      layer.style.opacity = parseFloat(styleOpacity.value);
      if (layer.type === 'track') layer.style.width = parseInt(lineWidth.value,10);
      if (layer.type === 'point') layer.style.radius = parseInt(pointRadius.value,10);
      rebuildAllLayers();
      modalBackdrop.style.display = 'none'; modalBackdrop.setAttribute('aria-hidden','true'); editingLayerId = null;
    };

    function rgbToHex(input) {
      if (!input) return '#000000';
      if (input[0] === '#') return input;
      const m = input.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return '#000000';
      const r = parseInt(m[1]), g = parseInt(m[2]), b = parseInt(m[3]);
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    /* ====== Export / Save state ====== */
    document.getElementById('exportGeoJSON').onclick = () => {
      const all = { type:'FeatureCollection', features: [] };
      state.layers.forEach(l => all.features.push(...l.geojson.features));
      const text = JSON.stringify(all, null, 2);
      const blob = new Blob([text], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'export_all.geojson'; a.click();
      URL.revokeObjectURL(url);
    };

    document.getElementById('exportState').onclick = () => {
      const text = JSON.stringify(state, null, 2);
      const blob = new Blob([text], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'map_state.json'; a.click();
      URL.revokeObjectURL(url);
    };

    function exportLayerGeoJSON(layer) {
      const text = JSON.stringify(layer.geojson, null, 2);
      const blob = new Blob([text], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = layer.name.replace(/\s+/g,'_') + '.geojson'; a.click();
      URL.revokeObjectURL(url);
    }

    /* ====== Basemap switching ====== */
    document.getElementById('basemapSelect').onchange = (e) => { switchBasemap(e.target.value); };
    function switchBasemap(key) {
      const def = basemapDefs[key] || basemapDefs.osm;
      if (map.getLayer('basemap-layer')) try { map.removeLayer('basemap-layer'); } catch(e){}
      if (map.getSource('basemap')) try { map.removeSource('basemap'); } catch(e){}
      map.addSource('basemap', { type: 'raster', tiles: def.tiles, tileSize: 256, attribution: def.attribution });
      map.addLayer({ id: 'basemap-layer', type: 'raster', source: 'basemap' }, undefined);
      rebuildAllLayers();
    }

    /* ====== Init ====== */
    refreshLayerList();

  </script>


<!-- Print button injection (safely adds button to your sidebar) -->
<script>
window.generatePDF = generatePDF;
  
(function(){
  function ensure(){
    const sidebar = document.getElementById('sidebar');
    if (!sidebar) return setTimeout(ensure,200);
    if (!document.getElementById('printMapBtn')){
      const btn = document.createElement('button');
      btn.id = 'printMapBtn';
      btn.className = 'btn';
      btn.textContent = 'Print Map (PDF)';
      btn.style.marginTop = '8px';
      // place after first control block (adjust if needed)
      const firstControl = sidebar.querySelector('.control');
      if (firstControl) firstControl.after(btn); else sidebar.appendChild(btn);
      btn.onclick = generatePDF;
    }
  }
  ensure();
})();

// Load external libs (turf + jspdf) dynamically and provide a ready promise
window._libsReady = (function(){
  let p = null;
  return function(){
    if (p) return p;
    p = new Promise((resolve,reject)=>{
      const urls = [
        'https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js',
        'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js'
      ];
      let loaded = 0;
      urls.forEach(u=>{
        const s = document.createElement('script');
        s.src = u;
        s.onload = ()=>{ loaded++; if (loaded===urls.length) resolve(); };
        s.onerror = ()=> reject(new Error('Failed load '+u));
        document.head.appendChild(s);
      });
    });
    return p;
  };
})();

// Haversine distance (meters)
function haversine(lon1,lat1,lon2,lat2){
  const R = 6371000;
  const toRad = Math.PI/180;
  const dLat = (lat2-lat1)*toRad;
  const dLon = (lon2-lon1)*toRad;
  const a = Math.sin(dLat/2)*Math.sin(dLat/2) + Math.cos(lat1*toRad)*Math.cos(lat2*toRad)*Math.sin(dLon/2)*Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// Build graticule (grid) for bounds with spacing in meters (250 m)
function buildGraticuleForBounds(bounds, spacingMeters){
  const minLng = bounds.getWest(), maxLng = bounds.getEast();
  const minLat = bounds.getSouth(), maxLat = bounds.getNorth();
  const meanLat = (minLat+maxLat)/2;
  const meterToDeg = 1 / (111320 * Math.cos(meanLat * Math.PI/180));
  const stepDeg = spacingMeters * meterToDeg;
  const features = [];
  const startLng = Math.ceil(minLng/stepDeg)*stepDeg;
  for (let lng = startLng; lng <= maxLng; lng += stepDeg){
    features.push({ type:'Feature', geometry:{ type:'LineString', coordinates:[[lng,minLat],[lng,maxLat]] } });
  }
  const startLat = Math.ceil(minLat/stepDeg)*stepDeg;
  for (let lat = startLat; lat <= maxLat; lat += stepDeg){
    features.push({ type:'Feature', geometry:{ type:'LineString', coordinates:[[minLng,lat],[maxLng,lat]] } });
  }
  return { type:'FeatureCollection', features };
}

// Ensure graticule layer exists and update labels positions for rendering into PDF
function ensureGridLayer(map){
  if (!map) return;
  if (!map.getSource('graticule-source')){
    map.addSource('graticule-source', { type:'geojson', data: { type:'FeatureCollection', features:[] } });
    map.addLayer({ id:'graticule-layer', type:'line', source:'graticule-source', paint:{ 'line-color':'#666', 'line-width':0.6, 'line-opacity':0.6 } });
  }
  function update(){
    const b = map.getBounds();
    const grid = buildGraticuleForBounds(b, 250);
    const src = map.getSource('graticule-source');
    if (src && src.setData) src.setData(grid);
    window._gridLabels = computeGridLabels(map, b, 250);
  }
  map.on('moveend', update);
  map.on('zoomend', update);
  update();
}

// compute positions for grid labels (we will draw them onto merged canvas)
function computeGridLabels(map, bounds, spacingMeters){
  const labels = [];
  const minLng = bounds.getWest(), maxLng = bounds.getEast();
  const minLat = bounds.getSouth(), maxLat = bounds.getNorth();
  const meanLat = (minLat+maxLat)/2;
  const meterToDeg = 1 / (111320 * Math.cos(meanLat * Math.PI/180));
  const stepDeg = spacingMeters * meterToDeg;
  const startLng = Math.ceil(minLng/stepDeg)*stepDeg;
  for (let lng = startLng; lng <= maxLng; lng += stepDeg){
    const p = map.project([lng, bounds.getNorth()]);
    labels.push({ x: p.x, y: Math.max(8, p.y-6), text: lng.toFixed(5) });
  }
  const startLat = Math.ceil(minLat/stepDeg)*stepDeg;
  for (let lat = startLat; lat <= maxLat; lat += stepDeg){
    const p = map.project([bounds.getWest(), lat]);
    labels.push({ x: Math.max(6, p.x+2), y: p.y, text: lat.toFixed(5) });
  }
  return labels;
}

// Scale info (pixel length and pretty label)
function updateScaleInfo(map){
  if (!map) return {pixelLen:100, label:'100 m', valueMeters:100};
  const refPx = 100;
  const h = map.getContainer().clientHeight;
  const p1 = map.unproject([0, h/2]);
  const p2 = map.unproject([refPx, h/2]);
  const meters = haversine(p1.lng, p1.lat, p2.lng, p2.lat);
  const nice = [1,2,5,10,20,50,100,200,500,1000,2000,5000,10000];
  let best = nice[0];
  for (let n of nice){ if (meters < n){ best = n; break; } best = n; }
  const pixelLen = refPx * (best / meters);
  return { pixelLen, label: best < 1000 ? `${best} m` : `${(best/1000).toFixed(2)} km`, valueMeters: best };
}

// Capture merged map image: map canvas + north-arrow + scale-bar + grid labels drawn onto one canvas
async function captureMergedMapImage(map){
  await window._libsReady();
  const canvas = map.getCanvas();
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  const w = Math.round(rect.width * dpr);
  const h = Math.round(rect.height * dpr);
  const out = document.createElement('canvas');
  out.width = w; out.height = h;
  const ctx = out.getContext('2d');
  // draw base map canvas (already contains graticule layer)
  ctx.drawImage(canvas, 0, 0, w, h);
  // north arrow (top-right)
  const arrowSize = Math.round(40 * dpr);
  const margin = Math.round(12 * dpr);
  ctx.save();
  ctx.fillStyle = '#111';
  const ax = w - margin - arrowSize/2;
  const ay = margin + arrowSize/2;
  ctx.beginPath();
  ctx.moveTo(ax, ay - arrowSize/2);
  ctx.lineTo(ax - arrowSize/2, ay + arrowSize/2);
  ctx.lineTo(ax + arrowSize/2, ay + arrowSize/2);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.font = `${12 * dpr}px Arial`;
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText('N', ax, ay - 2);
  ctx.restore();
  // scale bar (bottom-left)
  const scale = updateScaleInfo(map);
  const scalePx = Math.round(scale.pixelLen * dpr);
  const barW = Math.max(40 * dpr, scalePx);
  const barH = Math.round(6 * dpr);
  const bx = margin;
  const by = h - margin - barH;
  ctx.fillStyle = '#fff'; ctx.fillRect(bx - 2*dpr, by - 6*dpr, barW + 4*dpr, barH + 12*dpr);
  ctx.fillStyle = '#111'; ctx.fillRect(bx, by, barW, barH);
  ctx.fillStyle = '#000'; ctx.font = `${11 * dpr}px Arial`; ctx.textAlign='left'; ctx.fillText(scale.label, bx, by - 8*dpr);
  // draw grid labels computed earlier
  if (window._gridLabels && window._gridLabels.length){
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.font = `${10 * dpr}px Arial`;
    ctx.textAlign = 'left'; ctx.textBaseline = 'top';
    window._gridLabels.forEach(lbl => {
      const x = Math.round(lbl.x * dpr), y = Math.round(lbl.y * dpr);
      const padding = Math.round(2 * dpr);
      const metrics = ctx.measureText(lbl.text);
      const wbox = Math.round(metrics.width) + padding*2;
      const hbox = Math.round(12 * dpr);
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.fillRect(x - padding, y - padding, wbox, hbox);
      ctx.fillStyle = '#000';
      ctx.fillText(lbl.text, x, y);
    });
  }
  return out.toDataURL('image/png');
}

// Polygon stats using turf (area in Ha)
function generatePolygonStats(){
  const stats = [];
  if (!window.turf) return stats;
  if (!window.state || !Array.isArray(window.state.layers)) return stats;
  window.state.layers.forEach(layer => {
    if (layer.type === 'polygon'){
      layer.geojson.features.forEach((f, idx) => {
        try {
          const area = turf.area(f)/10000.0;
          stats.push({ name: layer.name + (layer.geojson.features.length>1 ? ' #' + (idx+1) : ''), area });
        } catch(e){}
      });
    }
  });
  return stats;
}

// Generate PDF (A4 landscape) — left map (68%), right legend & areas
async function generatePDF(){
  try { await window._libsReady(); } catch(e){ alert('Failed to load libs for PDF: ' + e.message); return; }
  const mapInstance = window.map;
  if (!mapInstance){ alert('Map not initialized'); return; }
  // ensure grid overlay exists and grid labels computed
  ensureGridLayer(mapInstance);
  // small delay to allow sources to update on moveend
  await new Promise(r=>setTimeout(r,250));
  const imgData = await captureMergedMapImage(mapInstance);
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF('landscape','mm','a4');
  const pw = pdf.internal.pageSize.getWidth();
  const ph = pdf.internal.pageSize.getHeight();
  const mapWmm = pw * 0.68;
  const mapHmm = ph - 20;
  const img = new Image();
  img.src = imgData;
  await new Promise(r=>{ img.onload = r; });
  const imgAspect = img.width / img.height;
  const targetW = mapWmm;
  const targetH = Math.min(mapHmm, mapWmm / imgAspect);
  pdf.addImage(imgData, 'PNG', 10, 10, targetW, targetH);
  // Right panel legend & areas
  const stats = generatePolygonStats();
  pdf.setFontSize(14); pdf.text('Legenda & Luas Blok', 12 + targetW, 16);
  pdf.setFontSize(11);
  let y = 24;
  let total = 0;
  stats.forEach(s => {
    pdf.text(`- ${s.name}: ${s.area.toFixed(2)} Ha`, 12 + targetW, y);
    y += 6;
    total += s.area;
  });
  pdf.setFontSize(12); pdf.text(`Total: ${total.toFixed(2)} Ha`, 12 + targetW, y+4);
  // Title
  pdf.setFontSize(16); pdf.text('PETA AREAL KEBUN', 10, ph - 6);
  pdf.save('map_export.pdf');
}
</script>

</body>
</html>
