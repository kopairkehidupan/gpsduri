<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <title>Peta MapLibre — GPX/GeoJSON Upload</title>

  <!-- MapLibre GL JS -->
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

  <!-- toGeoJSON (konversi GPX -> GeoJSON) -->
  <script src="https://unpkg.com/@mapbox/togeojson@0.16.2/togeojson.js"></script>

  <style>
    /* Simple ArcGIS-like layout: left sidebar + map right */
    html,body,#map { height: 100%; margin: 0; padding: 0; font-family: Inter, Arial, sans-serif; }
    #app { display: grid; grid-template-columns: 360px 1fr; height: 100vh; }
    #sidebar { background:#fff; border-right:1px solid #e6e6e6; padding:12px; box-sizing:border-box; overflow:auto;}
    h2 { margin:6px 0 12px; font-size:18px; }
    .control { margin-bottom:12px; }
    #map { position: relative; }

    .layer-item { display:flex; align-items:center; justify-content:space-between; padding:8px;border:1px solid #eee;border-radius:6px;margin-bottom:6px;}
    .btn { background:#2b6cb0;color:#fff;padding:6px 8px;border-radius:6px;border:none;cursor:pointer;}
    .btn.secondary { background:#edf2f7;color:#111; }
    input[type=file] { display:block; margin-top:8px; }
    .small { font-size:12px;color:#666; }
    label { display:block; margin-bottom:6px; font-weight:600; }
  </style>
</head>
<body>
  <div id="app">
    <aside id="sidebar">
      <h2>Peta — ArcGIS-like (MapLibre)</h2>

      <div class="control">
        <label>Upload file (GPX or GeoJSON)</label>
        <input id="fileInput" type="file" accept=".gpx,.xml,.geojson,.json" />
        <div style="margin-top:8px;">
          <button id="uploadToDrive" class="btn">Upload → Google Drive</button>
          <button id="addLocal" class="btn secondary">Load locally (tanpa upload)</button>
        </div>
        <div id="uploadStatus" class="small" style="margin-top:8px;"></div>
      </div>

      <div class="control">
        <label>Rendering options</label>
        <input type="checkbox" id="treatTrackAsPolygon" /> <label for="treatTrackAsPolygon" style="display:inline;font-weight:normal">Treat closed tracks as polygon</label><br>
        <input type="checkbox" id="autoZoom" checked/> <label for="autoZoom" style="display:inline;font-weight:normal">Auto zoom to uploaded data</label>
      </div>

      <div class="control">
        <label>Layers</label>
        <div id="layerList"></div>
      </div>

      <div class="control">
        <label>Export</label>
        <button id="exportGeoJSON" class="btn secondary">Export All GeoJSON</button>
      </div>

      <hr />
      <div class="small">
        <b>Notes:</b>
        <ul>
          <li>GPX tracks → converted to GeoJSON in browser</li>
          <li>Untuk polygon (batas blok), sebaiknya upload GeoJSON</li>
        </ul>
      </div>
    </aside>

    <div id="map"></div>
  </div>

  <script>
    /* ====== CONFIG ====== */
    const APPS_SCRIPT_URL = 'REPLACE_WITH_YOUR_APPS_SCRIPT_URL'; // <-- ganti dengan URL deploy Apps Script
    /* ArcGIS-pro like palette (example) */
    const COLORS = {
      trackLine: '#d35400',      // orange
      trackLineOutline: '#8e2b00',
      waypoint: '#1f78b4',
      polygonFill: '#f6e6d8',
      polygonOutline: '#d98b3a'
    };

    /* ====== Initialize MapLibre map (raster OSM base) ====== */
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        "version": 8,
        "sources": {
          "osm-tiles": {
            "type": "raster",
            "tiles": ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
            "tileSize": 256,
            "attribution": "© OpenStreetMap contributors"
          }
        },
        "layers": [
          { "id": "osm-tiles", "type": "raster", "source": "osm-tiles" }
        ]
      },
      center: [101.45, -0.45], // default center (sesuaikan)
      zoom: 11
    });

    map.addControl(new maplibregl.NavigationControl(), 'top-right');
    map.addControl(new maplibregl.ScaleControl({maxWidth:200, unit:'metric'}), 'bottom-right');

    /* ====== State ====== */
    const state = {
      layers: [], // {id, name, type, geojson, visible}
      nextId: 1
    };

    /* ====== Helpers ====== */
    function addLayerToMap(layerObj) {
      const id = 'layer-' + layerObj.id;
      // Add source
      if (map.getSource(id)) map.removeLayer(id), map.removeSource(id);

      map.addSource(id, { type: 'geojson', data: layerObj.geojson });

      if (layerObj.type === 'track') {
        // outline
        map.addLayer({
          id: id + '-outline',
          type: 'line',
          source: id,
          layout: { 'line-join': 'round', 'line-cap': 'round' },
          paint: { 'line-color': COLORS.trackLineOutline, 'line-width': 6, 'line-opacity': 0.9 },
          filter: ["all",
            ["in", ["geometry-type"], ["literal", ["LineString", "MultiLineString"]]]
          ]
        });
      
        // main line
        map.addLayer({
          id: id + '-line',
          type: 'line',
          source: id,
          layout: { 'line-join': 'round', 'line-cap': 'round' },
          paint: { 'line-color': COLORS.trackLine, 'line-width': 3, 'line-opacity': 1.0 },
          filter: ["all",
            ["in", ["geometry-type"], ["literal", ["LineString", "MultiLineString"]]]
          ]
        });
      } else if (layerObj.type === 'point') {
        map.addLayer({
          id: id + '-symbol',
          type: 'circle',
          source: id,
          filter: ["==", ["geometry-type"], "Point"],
          paint: {
            'circle-radius': 6,
            'circle-color': COLORS.waypoint,
            'circle-stroke-color': '#fff',
            'circle-stroke-width': 1
          }
        });
      } else if (layerObj.type === 'polygon') {
        map.addLayer({
          id: id + '-fill',
          type: 'fill',
          source: id,
          paint: { 'fill-color': COLORS.polygonFill, 'fill-opacity': 0.6 }
        });
        map.addLayer({
          id: id + '-outline',
          type: 'line',
          source: id,
          paint: { 'line-color': COLORS.polygonOutline, 'line-width': 2 }
        });
      }

      // add popup on click (for features)
      map.on('click', id + '-symbol', (e) => {
        const props = e.features[0].properties || {};
        new maplibregl.Popup()
          .setLngLat(e.lngLat)
          .setHTML('<b>Waypoint</b><br/>' + JSON.stringify(props))
          .addTo(map);
      });

      // track line click popup
      map.on('click', id + '-line', (e) => {
        const props = e.features[0].properties || {};
        new maplibregl.Popup()
          .setLngLat(e.lngLat)
          .setHTML('<b>Track</b><br/>' + JSON.stringify(props))
          .addTo(map);
      });
    }

    function refreshLayerList() {
      const list = document.getElementById('layerList');
      list.innerHTML = '';
      state.layers.forEach(layer => {
        const el = document.createElement('div');
        el.className = 'layer-item';
        el.innerHTML = `<div style="display:flex;gap:8px;align-items:center"><input type="checkbox" data-id="${layer.id}" ${layer.visible ? 'checked': ''}/> <div><b>${layer.name}</b><div class="small">${layer.type}</div></div></div>
                        <div style="display:flex;gap:6px;"><button class="btn secondary" data-action="zoom" data-id="${layer.id}">Zoom</button>
                        <button class="btn" data-action="remove" data-id="${layer.id}">Remove</button></div>`;
        list.appendChild(el);
      });

      // events
      list.querySelectorAll('input[type=checkbox]').forEach(cb => {
        cb.onchange = function() {
          const id = parseInt(this.dataset.id,10);
          const layer = state.layers.find(l => l.id === id);
          layer.visible = this.checked;
          toggleLayerVisibility(layer);
        };
      });
      list.querySelectorAll('button[data-action]').forEach(btn => {
        btn.onclick = function() {
          const id = parseInt(this.dataset.id,10);
          const layer = state.layers.find(l => l.id === id);
          if (this.dataset.action === 'zoom') {
            zoomToGeoJSON(layer.geojson);
          } else if (this.dataset.action === 'remove') {
            removeLayer(layer);
          }
        };
      });
    }

    function toggleLayerVisibility(layer) {
      const id = 'layer-' + layer.id;
      const visible = layer.visible;
      const suffixes = ['-outline','-line','-symbol','-fill'];
      suffixes.forEach(s => {
        const lid = id + s;
        if (map.getLayer(lid)) {
          map.setLayoutProperty(lid, 'visibility', visible ? 'visible' : 'none');
        }
      });
    }

    function removeLayer(layer) {
      const id = 'layer-' + layer.id;
      // remove all possible associated layers
      ['-outline','-line','-symbol','-fill'].forEach(s => {
        const lid = id + s;
        if (map.getLayer(lid)) map.removeLayer(lid);
      });
      if (map.getSource(id)) map.removeSource(id);
      state.layers = state.layers.filter(l => l.id !== layer.id);
      refreshLayerList();
    }

    function zoomToGeoJSON(geojson) {
      const coords = [];
      geojson.features.forEach(f => {
        const geom = f.geometry;
        if (!geom) return;
        if (geom.type === 'Point') coords.push(geom.coordinates);
        else if (geom.type === 'LineString') coords.push(...geom.coordinates);
        else if (geom.type === 'Polygon') coords.push(...geom.coordinates.flat());
      });
      if (coords.length === 0) return;
      const lats = coords.map(c => c[1]);
      const lngs = coords.map(c => c[0]);
      const minLat = Math.min(...lats), maxLat = Math.max(...lats);
      const minLng = Math.min(...lngs), maxLng = Math.max(...lngs);
      map.fitBounds([[minLng, minLat],[maxLng, maxLat]], {padding:40});
    }

    /* ====== File handling ====== */
    document.getElementById('addLocal').onclick = async () => {
      const input = document.getElementById('fileInput');
      if (!input.files || input.files.length === 0) { alert('Pilih file dulu'); return; }
      const file = input.files[0];
      await handleFileRead(file, {upload:false});
    };

    document.getElementById('uploadToDrive').onclick = async () => {
      const input = document.getElementById('fileInput');
      if (!input.files || input.files.length === 0) { alert('Pilih file dulu'); return; }
      document.getElementById('uploadStatus').textContent = 'Uploading...';
      const file = input.files[0];
      try {
        const res = await uploadToAppsScript(file);
        document.getElementById('uploadStatus').textContent = 'Uploaded: ' + res.name;
        // fetch content back via apps script endpoint
        const contentResp = await fetch(res.url);
        const text = await contentResp.text();
        await parseAndAddFileContent(text, file.name);
      } catch (err) {
        document.getElementById('uploadStatus').textContent = 'Error: ' + err.message;
      }
    };

    async function uploadToAppsScript(file) {
      // We send form-data POST to APPS_SCRIPT_URL
      const form = new FormData();
      form.append('filename', file.name);
      form.append('contentType', file.type || 'application/octet-stream');
      // For simplicity, read file as text and send as body param 'b64' base64 encoded
      const arr = await file.arrayBuffer();
      const b64 = arrayBufferToBase64(arr);
      form.append('b64', b64);

      const resp = await fetch(APPS_SCRIPT_URL, { method: 'POST', body: form });
      if (!resp.ok) throw new Error('Upload failed: ' + resp.status);
      const j = await resp.json();
      if (j.error) throw new Error(j.error);
      return j; // contains id, name, url
    }

    function arrayBufferToBase64(buffer) {
      let binary = '';
      const bytes = new Uint8Array(buffer);
      const len = bytes.byteLength;
      for (let i = 0; i < len; i++) binary += String.fromCharCode(bytes[i]);
      return btoa(binary);
    }

    async function handleFileRead(file, opts={upload:false}) {
      const text = await file.text();
      await parseAndAddFileContent(text, file.name);
    }

    async function parseAndAddFileContent(text, filename) {
      // Determine type by extension
      const name = filename.toLowerCase();
      let geojson = null;

      if (name.endsWith('.gpx') || text.trim().startsWith('<?xml')) {
        // parse GPX
        const parser = new DOMParser();
        const xml = parser.parseFromString(text, 'application/xml');
        geojson = toGeoJSON.gpx(xml);
      } else if (name.endsWith('.geojson') || name.endsWith('.json')) {
        try {
          geojson = JSON.parse(text);
        } catch (err) {
          alert('Failed parse JSON: ' + err.message); return;
        }
      } else {
        alert('Unsupported file type. Use GPX or GeoJSON.');
        return;
      }

      // Normalize and split into types: points, lines, polygons
      // toGeoJSON yields features of various types
      const points = {type:'FeatureCollection', features: []};
      const lines = {type:'FeatureCollection', features: []};
      const polygons = {type:'FeatureCollection', features: []};

      geojson.features.forEach(f => {
        if (!f.geometry) return;
        if (f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint') points.features.push(f);
        else if (f.geometry.type === 'LineString' || f.geometry.type === 'MultiLineString') {
          // if user checked treat track as polygon and the line is closed -> polygon
          const treatAsPoly = document.getElementById('treatTrackAsPolygon').checked;
          if (treatAsPoly && f.geometry.type === 'LineString') {
            const coords = f.geometry.coordinates;
            if (coords.length >= 3) {
              const first = coords[0], last = coords[coords.length-1];
              if (first[0] === last[0] && first[1] === last[1]) {
                // closed -> convert to polygon
                polygons.features.push({
                  type:'Feature',
                  properties: f.properties||{},
                  geometry: { type: 'Polygon', coordinates: [coords] }
                });
                return;
              }
            }
          }
          lines.features.push(f);
        } else if (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon') polygons.features.push(f);
      });

      // Add layers to state + map
      if (lines.features.length) addNewLayer(lines, 'track', filename + ' — tracks');
      if (points.features.length) addNewLayer(points, 'point', filename + ' — waypoints');
      if (polygons.features.length) addNewLayer(polygons, 'polygon', filename + ' — polygons');

      refreshLayerList();
      if (document.getElementById('autoZoom').checked) {
        // zoom to combined extent
        const combined = {type:'FeatureCollection', features: []};
        combined.features.push(...lines.features, ...points.features, ...polygons.features);
        zoomToGeoJSON(combined);
      }
    }

    function addNewLayer(geojson, type, name) {
      const layer = { id: state.nextId++, name, type, geojson, visible: true };
      state.layers.push(layer);
      addLayerToMap(layer);
    }

    /* ====== Export all GeoJSON ====== */
    document.getElementById('exportGeoJSON').onclick = () => {
      const all = { type:'FeatureCollection', features: [] };
      state.layers.forEach(l => all.features.push(...l.geojson.features));
      const text = JSON.stringify(all, null, 2);
      const blob = new Blob([text], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'export_all.geojson'; a.click();
      URL.revokeObjectURL(url);
    };

    // initial empty layer list
    refreshLayerList();

  </script>
</body>
</html>
