<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <title>Peta Leaflet — GPX/GeoJSON Upload & Print (Areal-only)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- toGeoJSON (GPX -> GeoJSON) -->
  <script src="https://unpkg.com/@mapbox/togeojson@0.16.2/togeojson.js"></script>

  <!-- turf for area calc -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <style>
    /* --- layout --- */
    html,body,#map { height: 100%; margin: 0; padding: 0; font-family: Inter, Arial, sans-serif; }
    #app { display: grid; grid-template-columns: 380px 1fr; height: 100vh; }
    #sidebar { background:#fff; border-right:1px solid #e6e6e6; padding:12px; box-sizing:border-box; overflow:auto;}
    h2 { margin:6px 0 12px; font-size:18px; }
    .control { margin-bottom:12px; }
    #map { position: relative; }

    .layer-item { display:flex;align-items:center;justify-content:space-between;padding:8px;border:1px solid #eee;border-radius:6px;margin-bottom:6px;}
    .layer-left { display:flex; gap:8px; align-items:center;}
    .btn { background:#2b6cb0;color:#fff;padding:6px 8px;border-radius:6px;border:none;cursor:pointer;}
    .btn.secondary { background:#edf2f7;color:#111; }
    .btn.warn { background:#d9534f; }
    input[type=file] { display:block; margin-top:8px; }
    .small { font-size:12px;color:#666; }
    label { display:block; margin-bottom:6px; font-weight:600; }

    /* North arrow overlay (visible on-screen and print) */
    .north-arrow {
      position: absolute;
      right: 12px;
      top: 12px;
      width: 56px;
      height: 56px;
      z-index: 800;
      pointer-events: none;
      display:flex;align-items:center;justify-content:center;
      background: rgba(255,255,255,0.9);
      border-radius:6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      font-weight:700;
    }

    /* Legend overlay (top-right under north arrow) */
    .map-legend {
      position: absolute;
      right: 12px;
      top: 80px;
      z-index: 800;
      background: rgba(255,255,255,0.95);
      padding: 8px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.12);
      max-width: 220px;
      font-size: 13px;
    }
    .legend-item { display:flex; align-items:center; gap:8px; margin-bottom:6px; }
    .legend-swatch { width:18px; height:12px; display:inline-block; border:1px solid #ddd; }

    /* Print button small */
    #printMapBtn { margin-top:8px; display:block; }

    /* Print-specific layout: hide sidebar, expand map, show print frame elements */
    @media print {
      @page { size: A4 landscape; margin: 10mm; }
      html, body { height: auto; }
      #app { display: block; }
      #sidebar { display: none !important; }
      #map { position: relative; height: calc(100vh - 20mm); } /* allow large map for print */
      .north-arrow, .map-legend { box-shadow: none; background: #fff; }
      /* print header/footer frame (drawn as DOM so browsers print it reliably) */
      body::before {
        content: 'PETA AREAL PERKEBUNAN';
        display:block;
        width:100%;
        text-align:center;
        font-family: Arial, Helvetica, sans-serif;
        font-weight:700;
        font-size:16pt;
        margin-bottom:6mm;
      }
      /* make sure buttons/inputs hidden */
      button, input, select { display: none !important; }
    }

    /* small responsive tweak */
    @media (max-width:900px){
      #app { grid-template-columns: 1fr; }
      #sidebar { position: relative; z-index: 900; }
    }
  </style>
</head>
<body>
  <div id="app">
    <aside id="sidebar">
      <h2>Peta — Leaflet (A)</h2>

      <div class="control">
        <label>Basemap</label>
        <select id="basemapSelect" class="basemap-select">
          <option value="osm">OpenStreetMap</option>
          <option value="terrain">Stamen Terrain</option>
          <option value="satellite">Esri WorldImagery</option>
          <option value="carto_light">Carto Light</option>
          <option value="carto_dark">Carto Dark</option>
        </select>
      </div>

      <div class="control">
        <label>Upload file (GPX or GeoJSON)</label>
        <input id="fileInput" type="file" accept=".gpx,.xml,.geojson,.json" />
        <div style="margin-top:8px;">
          <button id="uploadToDrive" class="btn">Upload → Google Drive</button>
          <button id="addLocal" class="btn secondary">Load locally (tanpa upload)</button>
          <button id="loadUploadedGPX" class="btn secondary" title="Load GPX yang sudah diupload di session ini">Load: Rangkum Langkimat.gpx</button>
        </div>
        <div id="uploadStatus" class="small" style="margin-top:8px;"></div>
      </div>

      <div class="control">
        <label>Rendering & Convert options</label>
        <input type="checkbox" id="treatTrackAsPolygon" /> <label for="treatTrackAsPolygon" style="display:inline;font-weight:normal">Treat closed tracks as polygon</label><br>
        <input type="checkbox" id="simplifyOnConvert" /> <label for="simplifyOnConvert" style="display:inline;font-weight:normal">Simplify converted polygons</label><br>
        <label class="muted">Simplify tolerance (m)</label>
        <input id="simplifyTolerance" type="range" min="0" max="50" step="1" value="5" />
        <div class="muted">Auto zoom <input type="checkbox" id="autoZoom" checked style="margin-left:8px"/></div>
      </div>

      <div class="control">
        <label>Layers</label>
        <div id="layerList"></div>
      </div>

      <div class="control">
        <label>Export / Print</label>
        <div style="display:flex; gap:8px; flex-direction:column;">
          <button id="printMapBtn" class="btn">Print Map (Browser Print)</button>
          <button id="exportGeoJSON" class="btn secondary">Export All GeoJSON</button>
          <button id="exportState" class="btn secondary">Download State</button>
        </div>
      </div>

      <div class="small legend" id="legend">
        <b>Legend:</b>
        <div id="legendItems"></div>
      </div>
    </aside>

    <div id="map"></div>
    <div class="north-arrow" id="northArrow" aria-hidden="true">
      <svg width="36" height="36" viewBox="0 0 24 24" aria-hidden="true">
        <polygon points="12,2 4,22 12,18 20,22" fill="#111"/>
        <text x="12" y="10" fill="#fff" font-size="6" font-weight="700" text-anchor="middle">N</text>
      </svg>
    </div>

    <div class="map-legend" id="mapLegend" aria-hidden="false">
      <div style="font-weight:700; margin-bottom:6px;">Legenda</div>
      <div id="mapLegendItems"></div>
      <div style="border-top:1px solid #eee; margin-top:8px; padding-top:6px; font-size:12px;">
        <div style="font-weight:700;">Luas Blok (Ha)</div>
        <div id="areaSummary" style="margin-top:6px;"></div>
      </div>
    </div>
  </div>

  <!-- modal style editor -->
  <div id="modalBackdrop" class="modal-backdrop" role="dialog" aria-hidden="true" style="display:none;">
    <div class="modal" role="document">
      <h3 id="modalTitle">Edit Layer</h3>
      <div id="modalBody">
        <div class="form-row"><label>Color</label><input type="color" id="styleColor" /></div>
        <div class="form-row" id="lineOptions"><label>Line width</label><input id="lineWidth" type="range" min="1" max="12" value="3" /></div>
        <div class="form-row" id="radiusOptions" style="display:none"><label>Radius</label><input id="pointRadius" type="range" min="1" max="20" value="6" /></div>
        <div class="form-row"><label>Opacity</label><input id="styleOpacity" type="range" min="0" max="1" step="0.05" value="1" /></div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px;">
          <button id="modalCancel" class="btn secondary">Cancel</button>
          <button id="modalSave" class="btn">Save</button>
        </div>
      </div>
    </div>
  </div>

<script>
/* ====== CONFIG ====== */
const APPS_SCRIPT_URL = 'REPLACE_WITH_YOUR_APPS_SCRIPT_URL';
const UPLOADED_GPX_PATH = '/mnt/data/Rangkum Langkimat.gpx';

const DEFAULT_STYLE = {
  trackLine: '#d35400',
  waypoint: '#1f78b4',
  polygonFill: '#f6e6d8',
  polygonOutline: '#d98b3a'
};

window.state = { layers: [], nextId: 1 };

/* ====== Init Leaflet map ====== */
const map = L.map('map', { preferCanvas: true }).setView([-0.45, 101.45], 11);
window.map = map;

// basemap definitions
const basemapDefs = {
  osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '© OpenStreetMap contributors' }),
  terrain: L.tileLayer('https://stamen-tiles.a.ssl.fastly.net/terrain/{z}/{x}/{y}.jpg', { maxZoom: 18, attribution: 'Stamen Terrain' }),
  satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { maxZoom: 18, attribution: 'Esri World Imagery' }),
  carto_light: L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', { maxZoom: 19, attribution: 'Carto Light' }),
  carto_dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', { maxZoom: 19, attribution: 'Carto Dark' })
};

// add default
let currentBase = basemapDefs.osm.addTo(map);
function switchBasemap(key){
  try{ if (currentBase) map.removeLayer(currentBase); }catch(e){}
  currentBase = basemapDefs[key] || basemapDefs.osm;
  currentBase.addTo(map);
}
document.getElementById('basemapSelect').value = 'osm';
document.getElementById('basemapSelect').onchange = (e) => switchBasemap(e.target.value);

L.control.scale({ metric: true, imperial: false }).addTo(map);

/* ====== Utility: simplify RDP (coords: [lng,lat]) ====== */
function simplifyRDP(coords, toleranceMeters) {
  if (!coords || coords.length < 3) return coords.slice();
  const meanLat = coords.reduce((s,c)=>s + c[1],0)/coords.length;
  const meterToDeg = 1 / (111320 * Math.cos(meanLat * Math.PI/180));
  const eps = toleranceMeters * meterToDeg;
  function sqDist(a,b){ const dx=a[0]-b[0], dy=a[1]-b[1]; return dx*dx + dy*dy; }
  function distToSeg2(p, v, w){
    const l2 = sqDist(v,w); if (l2===0) return sqDist(p,v);
    let t = ((p[0]-v[0])*(w[0]-v[0]) + (p[1]-v[1])*(w[1]-v[1]))/l2;
    t = Math.max(0, Math.min(1, t));
    const proj = [ v[0] + t*(w[0]-v[0]), v[1] + t*(w[1]-v[1]) ];
    return sqDist(p, proj);
  }
  function rdp(points, eps){
    const n = points.length;
    const keep = new Array(n).fill(false);
    keep[0] = keep[n-1] = true;
    const stack = [[0,n-1]];
    while(stack.length){
      const [i,j] = stack.pop();
      let maxd=0, idx=-1;
      for(let k=i+1;k<j;k++){
        const d = distToSeg2(points[k], points[i], points[j]);
        if (d > maxd){ maxd = d; idx = k; }
      }
      if (Math.sqrt(maxd) > eps){
        keep[idx]=true;
        stack.push([i,idx]); stack.push([idx,j]);
      }
    }
    const res = [];
    for(let i=0;i<n;i++) if (keep[i]) res.push(points[i]);
    return res;
  }
  return rdp(coords, eps);
}

/* ====== Layer management (Leaflet GeoJSON layers) ====== */
function addNewLayer(geojson, type, name){
  const id = window.state.nextId++;
  const layerObj = {
    id, name, type, geojson,
    visible: true,
    style: {
      color: type==='track' ? DEFAULT_STYLE.trackLine : type==='point' ? DEFAULT_STYLE.waypoint : DEFAULT_STYLE.polygonFill,
      width: type==='track' ? 3 : undefined,
      opacity: 1,
      radius: type==='point' ? 6 : undefined
    },
    leafletLayer: null
  };
  // create leaflet layer
  const opts = {};
  if (type === 'point'){
    opts.pointToLayer = (f,latlng) => L.circleMarker(latlng, { radius: layerObj.style.radius, color: layerObj.style.color, weight:1, fillOpacity: layerObj.style.opacity, fillColor: layerObj.style.color });
  } else {
    opts.style = (f) => {
      if (type === 'polygon') return { color: layerObj.style.color, weight: layerObj.style.width || 2, fillColor: layerObj.style.color, fillOpacity: layerObj.style.opacity || 0.6 };
      return { color: layerObj.style.color, weight: layerObj.style.width || 3, opacity: layerObj.style.opacity || 1 };
    };
  }
  const leafletLayer = L.geoJSON(geojson, opts).addTo(map);
  layerObj.leafletLayer = leafletLayer;
  window.state.layers.push(layerObj);
  refreshLayerList(); refreshLegend(); populateMapLegend();
  return layerObj;
}

function removeLayerById(id){
  const idx = window.state.layers.findIndex(l=>l.id===id);
  if (idx===-1) return;
  const l = window.state.layers[idx];
  if (l.leafletLayer) map.removeLayer(l.leafletLayer);
  window.state.layers.splice(idx,1);
  refreshLayerList(); refreshLegend(); populateMapLegend();
}

function rebuildAllLayers(){
  window.state.layers.forEach(l => { if (l.leafletLayer) map.removeLayer(l.leafletLayer); l.leafletLayer = null; });
  window.state.layers.forEach(l => {
    const opts = {};
    if (l.type === 'point') opts.pointToLayer = (f,latlng) => L.circleMarker(latlng, { radius: l.style.radius, color: l.style.color, weight:1, fillOpacity: l.style.opacity, fillColor: l.style.color });
    else opts.style = (f) => l.type==='polygon' ? { color: l.style.color, weight: l.style.width || 2, fillColor: l.style.color, fillOpacity: l.style.opacity || 0.6 } : { color: l.style.color, weight: l.style.width || 3, opacity: l.style.opacity || 1 };
    l.leafletLayer = L.geoJSON(l.geojson, opts).addTo(map);
  });
  refreshLayerList(); refreshLegend(); populateMapLegend();
}

/* ====== UI: layer list & legend ====== */
function refreshLayerList(){
  const list = document.getElementById('layerList');
  list.innerHTML = '';
  window.state.layers.slice().reverse().forEach(layer => {
    const el = document.createElement('div'); el.className='layer-item';
    const left = document.createElement('div'); left.className='layer-left';
    const cb = document.createElement('input'); cb.type='checkbox'; cb.checked = layer.visible; cb.dataset.id = layer.id;
    cb.onchange = () => { layer.visible = cb.checked; if (layer.leafletLayer) { if (cb.checked) map.addLayer(layer.leafletLayer); else map.removeLayer(layer.leafletLayer); } refreshLegend(); populateMapLegend(); };
    const title = document.createElement('div'); title.innerHTML = `<b>${layer.name}</b><div class="small">${layer.type}</div>`;
    left.appendChild(cb); left.appendChild(title);

    const right = document.createElement('div'); right.className='layer-actions';
    const btnStyle = document.createElement('button'); btnStyle.className='btn secondary'; btnStyle.textContent='Style'; btnStyle.onclick = () => openStyleModal(layer.id);
    const btnUp = document.createElement('button'); btnUp.className='btn'; btnUp.textContent='▲'; btnUp.title='Move up'; btnUp.onclick = () => moveLayer(layer.id, -1);
    const btnDown = document.createElement('button'); btnDown.className='btn'; btnDown.textContent='▼'; btnDown.title='Move down'; btnDown.onclick = () => moveLayer(layer.id, 1);
    const btnZoom = document.createElement('button'); btnZoom.className='btn secondary'; btnZoom.textContent='Zoom'; btnZoom.onclick = () => { try{ map.fitBounds(layer.leafletLayer.getBounds()); }catch(e){} };
    const btnExport = document.createElement('button'); btnExport.className='btn secondary'; btnExport.textContent='Export'; btnExport.onclick = () => exportLayerGeoJSON(layer);
    const btnConvert = document.createElement('button'); btnConvert.className='btn secondary'; btnConvert.textContent='Convert'; btnConvert.title='Convert track→polygon if closed'; btnConvert.onclick = () => convertTrackToPolygon(layer.id);
    const btnRemove = document.createElement('button'); btnRemove.className='btn warn'; btnRemove.textContent='Remove'; btnRemove.onclick = () => removeLayerById(layer.id);

    right.appendChild(btnStyle);
    right.appendChild(btnUp);
    right.appendChild(btnDown);
    right.appendChild(btnZoom);
    right.appendChild(btnExport);
    right.appendChild(btnConvert);
    right.appendChild(btnRemove);

    el.appendChild(left); el.appendChild(right);
    list.appendChild(el);
  });
}

function refreshLegend(){
  const node = document.getElementById('legendItems');
  node.innerHTML = '';
  window.state.layers.forEach(l => {
    const div = document.createElement('div');
    const sample = document.createElement('span');
    sample.style.display='inline-block'; sample.style.width='18px'; sample.style.height='12px'; sample.style.marginRight='8px';
    const color = (l.style && l.style.color) || (l.type === 'track' ? DEFAULT_STYLE.trackLine : l.type==='point' ? DEFAULT_STYLE.waypoint : DEFAULT_STYLE.polygonFill);
    sample.style.background = color;
    div.innerHTML = `<b>${l.name}</b> <span class="small">(${l.type})</span>`;
    div.prepend(sample);
    node.appendChild(div);
  });
}

function populateMapLegend(){
  const node = document.getElementById('mapLegendItems');
  node.innerHTML = '';
  window.state.layers.forEach(l => {
    if (!l.visible) return;
    const row = document.createElement('div'); row.className = 'legend-item';
    const sw = document.createElement('span'); sw.className = 'legend-swatch';
    sw.style.background = (l.style && l.style.color) || '#000';
    row.appendChild(sw);
    const txt = document.createElement('div'); txt.textContent = l.name;
    row.appendChild(txt);
    node.appendChild(row);
  });
  // update area summary
  const summaryNode = document.getElementById('areaSummary');
  summaryNode.innerHTML = '';
  const stats = generatePolygonStats();
  if (stats.length === 0) summaryNode.textContent = '-';
  else {
    stats.forEach(s=>{
      const div = document.createElement('div');
      div.textContent = `${s.name}: ${s.area.toFixed(2)} Ha`;
      summaryNode.appendChild(div);
    });
  }
}

/* ====== File handling & parsing ====== */
document.getElementById('addLocal').onclick = async () => {
  const input = document.getElementById('fileInput');
  if (!input.files || input.files.length === 0) { alert('Pilih file dulu'); return; }
  const file = input.files[0];
  const text = await file.text();
  await parseAndAddFileContent(text, file.name);
};

document.getElementById('uploadToDrive').onclick = async () => {
  const input = document.getElementById('fileInput');
  if (!input.files || input.files.length === 0) { alert('Pilih file dulu'); return; }
  document.getElementById('uploadStatus').textContent = 'Uploading...';
  const file = input.files[0];
  try {
    const form = new FormData();
    form.append('filename', file.name);
    form.append('contentType', file.type || 'application/octet-stream');
    const arr = await file.arrayBuffer();
    const b64 = arrayBufferToBase64(arr);
    form.append('b64', b64);
    const resp = await fetch(APPS_SCRIPT_URL, { method: 'POST', body: form });
    if (!resp.ok) throw new Error('Upload failed: ' + resp.status);
    const j = await resp.json();
    if (j.error) throw new Error(j.error);
    document.getElementById('uploadStatus').textContent = 'Uploaded: ' + j.name;
    if (j.url){
      const contentResp = await fetch(j.url);
      const text = await contentResp.text();
      await parseAndAddFileContent(text, file.name);
    }
  } catch (err){
    document.getElementById('uploadStatus').textContent = 'Error: ' + err.message;
  }
};

document.getElementById('loadUploadedGPX').onclick = async () => {
  try {
    const resp = await fetch(UPLOADED_GPX_PATH);
    if (!resp.ok) throw new Error('Fetch failed: ' + resp.status);
    const text = await resp.text();
    await parseAndAddFileContent(text, 'Rangkum Langkimat.gpx');
  } catch (err){
    alert('Gagal load uploaded GPX: ' + err.message + '\n(If running locally, ensure your environment serves that path.)');
  }
};

function arrayBufferToBase64(buffer) {
  let binary = '';
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
}

async function parseAndAddFileContent(text, filename){
  const name = filename.toLowerCase();
  let geojson = null;
  if (name.endsWith('.gpx') || text.trim().startsWith('<?xml')) {
    const parser = new DOMParser();
    const xml = parser.parseFromString(text, 'application/xml');
    geojson = toGeoJSON.gpx(xml);
  } else if (name.endsWith('.geojson') || name.endsWith('.json')) {
    geojson = JSON.parse(text);
  } else {
    alert('Unsupported file type. Use GPX or GeoJSON.');
    return;
  }

  // split features
  const points = { type:'FeatureCollection', features:[] };
  const lines = { type:'FeatureCollection', features:[] };
  const polygons = { type:'FeatureCollection', features:[] };

  geojson.features.forEach(f=>{
    if (!f.geometry) return;
    const t = f.geometry.type;
    if (t === 'Point' || t === 'MultiPoint') points.features.push(f);
    else if (t === 'LineString' || t === 'MultiLineString'){
      const treatAsPoly = document.getElementById('treatTrackAsPolygon').checked;
      if (treatAsPoly && t === 'LineString'){
        const coords = f.geometry.coordinates;
        if (coords.length >= 3 && isRingClosed(coords)){
          const ring = closeRing(coords);
          polygons.features.push({ type:'Feature', properties: f.properties||{}, geometry: { type:'Polygon', coordinates: [ring] } });
          return;
        }
      }
      lines.features.push(f);
    } else if (t === 'Polygon' || t === 'MultiPolygon') polygons.features.push(f);
  });

  if (lines.features.length) addNewLayer(lines, 'track', filename + ' — tracks');
  if (points.features.length) addNewLayer(points, 'point', filename + ' — waypoints');
  if (polygons.features.length) addNewLayer(polygons, 'polygon', filename + ' — polygons');

  if (document.getElementById('autoZoom').checked){
    const group = L.featureGroup(window.state.layers.map(l => l.leafletLayer).filter(Boolean));
    if (group.getLayers().length) map.fitBounds(group.getBounds().pad(0.1));
  }
}

function isRingClosed(coords, tolerance=1e-6){
  if (!coords || coords.length < 3) return false;
  const a = coords[0], b = coords[coords.length-1];
  if (Math.abs(a[0]-b[0]) <= tolerance && Math.abs(a[1]-b[1]) <= tolerance) return true;
  return false;
}
function closeRing(coords){
  const ring = coords.slice();
  const a = ring[0], b = ring[ring.length-1];
  if (a[0] !== b[0] || a[1] !== b[1]) ring.push([a[0], a[1]]);
  return ring;
}

/* convert track to polygon */
function convertTrackToPolygon(layerId){
  const layer = window.state.layers.find(l=>l.id===layerId);
  if (!layer || layer.type !== 'track') { alert('Layer bukan track'); return; }
  const simplify = document.getElementById('simplifyOnConvert').checked;
  const tolMeters = parseFloat(document.getElementById('simplifyTolerance').value || '0');
  const polygons = { type:'FeatureCollection', features:[] };
  layer.geojson.features.forEach(f=>{
    const g = f.geometry; if (!g) return;
    if (g.type === 'LineString'){
      let coords = g.coordinates.slice();
      if (!isRingClosed(coords)) coords = closeRing(coords);
      if (coords.length >= 4){
        if (simplify && tolMeters>0) coords = simplifyRDP(coords, tolMeters);
        if (!isRingClosed(coords)) coords.push([coords[0][0], coords[0][1]]);
        if (coords.length >= 4) polygons.features.push({ type:'Feature', properties: f.properties||{}, geometry: { type:'Polygon', coordinates: [coords] } });
      }
    } else if (g.type === 'MultiLineString'){
      g.coordinates.forEach(arr=>{
        let coords = arr.slice();
        if (!isRingClosed(coords)) coords = closeRing(coords);
        if (coords.length >= 4){
          if (simplify && tolMeters>0) coords = simplifyRDP(coords, tolMeters);
          if (!isRingClosed(coords)) coords.push([coords[0][0], coords[0][1]]);
          if (coords.length >= 4) polygons.features.push({ type:'Feature', properties: f.properties||{}, geometry: { type:'Polygon', coordinates: [coords] } });
        }
      });
    }
  });
  if (!polygons.features.length) { alert('Tidak ada track tertutup untuk dikonversi.'); return; }
  addNewLayer(polygons, 'polygon', layer.name + ' — converted polygons');
}

/* ====== Style modal ====== */
const modalBackdrop = document.getElementById('modalBackdrop');
const styleColor = document.getElementById('styleColor');
const styleOpacity = document.getElementById('styleOpacity');
const lineWidth = document.getElementById('lineWidth');
const pointRadius = document.getElementById('pointRadius');
let editingLayerId = null;

function openStyleModal(layerId){
  const layer = window.state.layers.find(l=>l.id===layerId);
  if (!layer) return;
  editingLayerId = layerId;
  document.getElementById('modalTitle').textContent = 'Edit: ' + layer.name;
  styleColor.value = (layer.style && layer.style.color) ? rgbToHex(layer.style.color) : '#ff0000';
  styleOpacity.value = (typeof layer.style.opacity === 'number') ? layer.style.opacity : 1;
  lineWidth.value = (layer.style && layer.style.width) ? layer.style.width : 3;
  pointRadius.value = (layer.style && layer.style.radius) ? layer.style.radius : 6;
  document.getElementById('lineOptions').style.display = layer.type==='track' || layer.type==='polygon' ? 'flex' : 'none';
  document.getElementById('radiusOptions').style.display = layer.type==='point' ? 'flex' : 'none';
  modalBackdrop.style.display = 'flex'; modalBackdrop.setAttribute('aria-hidden','false');
}
document.getElementById('modalCancel').onclick = () => { modalBackdrop.style.display='none'; modalBackdrop.setAttribute('aria-hidden','true'); editingLayerId=null; };
document.getElementById('modalSave').onclick = () => {
  if (!editingLayerId) return;
  const layer = window.state.layers.find(l=>l.id===editingLayerId);
  if (!layer) return;
  layer.style = layer.style || {};
  layer.style.color = styleColor.value;
  layer.style.opacity = parseFloat(styleOpacity.value);
  if (layer.type === 'track') layer.style.width = parseInt(lineWidth.value,10);
  if (layer.type === 'point') layer.style.radius = parseInt(pointRadius.value,10);
  rebuildAllLayers();
  modalBackdrop.style.display='none'; modalBackdrop.setAttribute('aria-hidden','true'); editingLayerId=null;
};

function rgbToHex(input){
  if (!input) return '#000000';
  if (input[0] === '#') return input;
  const m = input.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
  if (!m) return '#000000';
  const r = parseInt(m[1]), g = parseInt(m[2]), b = parseInt(m[3]);
  return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

/* ====== Polygon stats using turf (area in Ha) ====== */
function generatePolygonStats(){
  const stats = [];
  if (!window.turf) return stats;
  window.state.layers.forEach(layer=>{
    if (layer.type === 'polygon'){
      layer.geojson.features.forEach((f, idx)=>{
        try {
          const area = turf.area(f)/10000.0;
          stats.push({ name: layer.name + (layer.geojson.features.length>1 ? ' #' + (idx+1) : ''), area });
        } catch(e){}
      });
    }
  });
  return stats;
}

/* ====== Grid (graticule) creation – returns GeoJSON for lines spaced by meters ====== */
function buildGraticuleForBounds(bounds, spacingMeters){
  const minLng = bounds.getWest(), maxLng = bounds.getEast();
  const minLat = bounds.getSouth(), maxLat = bounds.getNorth();
  const meanLat = (minLat+maxLat)/2;
  const meterToDeg = 1 / (111320 * Math.cos(meanLat * Math.PI/180));
  const stepDeg = spacingMeters * meterToDeg;
  const feats = [];
  const startLng = Math.ceil(minLng/stepDeg)*stepDeg;
  for (let lng = startLng; lng <= maxLng; lng += stepDeg){
    feats.push({ type:'Feature', geometry: { type:'LineString', coordinates: [[lng, minLat], [lng, maxLat]] } });
  }
  const startLat = Math.ceil(minLat/stepDeg)*stepDeg;
  for (let lat = startLat; lat <= maxLat; lat += stepDeg){
    feats.push({ type:'Feature', geometry: { type:'LineString', coordinates: [[minLng, lat], [maxLng, lat]] } });
  }
  return { type:'FeatureCollection', features: feats };
}

let graticuleLayer = null;
function ensureGrid(){
  const b = map.getBounds();
  const grid = buildGraticuleForBounds(b, 250);
  if (!graticuleLayer) {
    graticuleLayer = L.geoJSON(grid, { style: { color: '#666', weight: 0.6, opacity: 0.6 } }).addTo(map);
  } else {
    graticuleLayer.clearLayers();
    L.geoJSON(grid, { style: { color: '#666', weight: 0.6, opacity: 0.6 } }).eachLayer(l => graticuleLayer.addLayer(l));
  }
  window._gridLabels = computeGridLabels(map, b, 250);
  populateMapLegend(); // update labels
}
map.on('moveend', ensureGrid);
map.on('zoomend', ensureGrid);
ensureGrid();

function computeGridLabels(map, bounds, spacingMeters){
  const labels = [];
  const minLng = bounds.getWest(), maxLng = bounds.getEast();
  const minLat = bounds.getSouth(), maxLat = bounds.getNorth();
  const meanLat = (minLat+maxLat)/2;
  const meterToDeg = 1 / (111320 * Math.cos(meanLat * Math.PI/180));
  const stepDeg = spacingMeters * meterToDeg;
  const startLng = Math.ceil(minLng/stepDeg)*stepDeg;
  for (let lng = startLng; lng <= maxLng; lng += stepDeg){
    const p = map.latLngToContainerPoint([bounds.getNorth(), lng]);
    labels.push({ x: p.x, y: Math.max(8, p.y-6), text: lng.toFixed(5) });
  }
  const startLat = Math.ceil(minLat/stepDeg)*stepDeg;
  for (let lat = startLat; lat <= maxLat; lat += stepDeg){
    const p = map.latLngToContainerPoint([lat, bounds.getWest()]);
    labels.push({ x: Math.max(6, p.x+2), y: p.y, text: lat.toFixed(5) });
  }
  return labels;
}

/* ====== Print handling (browser print) ====== */
document.getElementById('printMapBtn').onclick = () => {
  // prepare legend/area before print
  populateMapLegend();
  // ensure grid up-to-date
  ensureGrid();
  // small delay to allow DOM updates then print
  setTimeout(()=> window.print(), 200);
};

window.onbeforeprint = () => {
  // ensure legend/areas visible and up to date for print
  populateMapLegend();
  // increase map redraw for print resolution
  map.invalidateSize();
};

window.onafterprint = () => {
  // restore anything if needed
  map.invalidateSize();
};

/* ====== small helpers ====== */
function generateId(){ return 'id' + Math.random().toString(36).slice(2,9); }

function moveLayer(id, delta){
  const idx = window.state.layers.findIndex(l=>l.id===id);
  if (idx===-1) return;
  const newIdx = idx + delta;
  if (newIdx < 0 || newIdx >= window.state.layers.length) return;
  [window.state.layers[idx], window.state.layers[newIdx]] = [window.state.layers[newIdx], window.state.layers[idx]];
  rebuildAllLayers();
}

function exportLayerGeoJSON(layer){
  const text = JSON.stringify(layer.geojson, null, 2);
  const blob = new Blob([text], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = layer.name.replace(/\s+/g,'_') + '.geojson'; a.click();
  URL.revokeObjectURL(url);
}

/* ====== Init UI actions already bound earlier to functions that exist; refresh UI initial state ====== */
refreshLayerList(); refreshLegend(); populateMapLegend();

</script>
</body>
</html>
