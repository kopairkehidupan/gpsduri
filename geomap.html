<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <title>Peta MapLibre — GPX/GeoJSON Upload & Layer Editor</title>

  <!-- MapLibre GL JS -->
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

  <!-- toGeoJSON (konversi GPX -> GeoJSON) -->
  <script src="https://unpkg.com/@mapbox/togeojson@0.16.2/togeojson.js"></script>

  <style>
    html,body,#map { height: 100%; margin: 0; padding: 0; font-family: Inter, Arial, sans-serif; }
    #app { display: grid; grid-template-columns: 360px 1fr; height: 100vh; }
    #sidebar { background:#fff; border-right:1px solid #e6e6e6; padding:12px; box-sizing:border-box; overflow:auto;}
    h2 { margin:6px 0 12px; font-size:18px; }
    .control { margin-bottom:12px; }
    #map { position: relative; }

    .layer-item { display:flex;align-items:center;justify-content:space-between;padding:8px;border:1px solid #eee;border-radius:6px;margin-bottom:6px;}
    .layer-left { display:flex; gap:8px; align-items:center;}
    .btn { background:#2b6cb0;color:#fff;padding:6px 8px;border-radius:6px;border:none;cursor:pointer;}
    .btn.secondary { background:#edf2f7;color:#111; }
    .btn.warn { background:#d9534f; }
    input[type=file] { display:block; margin-top:8px; }
    .small { font-size:12px;color:#666; }
    label { display:block; margin-bottom:6px; font-weight:600; }

    /* Modal */
    .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.4); display:none; align-items:center; justify-content:center; z-index:9999;}
    .modal { background:#fff; width:420px; border-radius:8px; padding:16px; box-shadow:0 8px 24px rgba(0,0,0,0.2); }
    .modal h3 { margin:0 0 8px; font-size:16px; }
    .form-row { margin:8px 0; display:flex; align-items:center; gap:8px; justify-content:space-between; }
    .form-row input[type="range"] { width:180px; }
    .legend { margin-top:12px; border-top:1px solid #eee; padding-top:8px; font-size:13px; }
    .basemap-select { width:100%; padding:6px; border-radius:6px; border:1px solid #ddd; }
    .layer-actions { display:flex; gap:6px; }
  </style>
</head>
<body>
  <div id="app">
    <aside id="sidebar">
      <h2>Peta — ArcGIS-like (MapLibre)</h2>

      <div class="control">
        <label>Basemap</label>
        <select id="basemapSelect" class="basemap-select">
          <option value="osm">OpenStreetMap</option>
          <option value="terrain">Terrain (Stamen Terrain)</option>
          <option value="satellite">Satellite (Esri.WorldImagery)</option>
          <option value="light">Light (Carto)</option>
          <option value="dark">Dark (Carto)</option>
        </select>
      </div>

      <div class="control">
        <label>Upload file (GPX or GeoJSON)</label>
        <input id="fileInput" type="file" accept=".gpx,.xml,.geojson,.json" />
        <div style="margin-top:8px;">
          <button id="uploadToDrive" class="btn">Upload → Google Drive</button>
          <button id="addLocal" class="btn secondary">Load locally (tanpa upload)</button>
          <button id="loadUploadedGPX" class="btn secondary" title="Load GPX yang sudah diupload di session ini">Load: Rangkum Langkimat.gpx</button>
        </div>
        <div id="uploadStatus" class="small" style="margin-top:8px;"></div>
      </div>

      <div class="control">
        <label>Rendering options</label>
        <input type="checkbox" id="treatTrackAsPolygon" /> <label for="treatTrackAsPolygon" style="display:inline;font-weight:normal">Treat closed tracks as polygon</label><br>
        <input type="checkbox" id="autoZoom" checked/> <label for="autoZoom" style="display:inline;font-weight:normal">Auto zoom to uploaded data</label>
      </div>

      <div class="control">
        <label>Layers</label>
        <div id="layerList"></div>
      </div>

      <div class="control">
        <label>Export</label>
        <div style="display:flex; gap:8px;">
          <button id="exportGeoJSON" class="btn secondary">Export All GeoJSON</button>
          <button id="exportState" class="btn secondary">Download State</button>
        </div>
      </div>

      <div class="small legend" id="legend">
        <b>Legend:</b>
        <div id="legendItems"></div>
      </div>
    </aside>

    <div id="map"></div>
  </div>

  <!-- STYLE EDITOR MODAL -->
  <div id="modalBackdrop" class="modal-backdrop" role="dialog" aria-hidden="true">
    <div class="modal" role="document">
      <h3 id="modalTitle">Edit Layer</h3>
      <div id="modalBody">
        <!-- dynamic content -->
        <div class="form-row"><label>Color</label><input type="color" id="styleColor" /></div>
        <div class="form-row" id="lineOptions"><label>Line width</label><input id="lineWidth" type="range" min="1" max="12" value="3" /></div>
        <div class="form-row" id="radiusOptions" style="display:none"><label>Radius</label><input id="pointRadius" type="range" min="1" max="20" value="6" /></div>
        <div class="form-row"><label>Opacity</label><input id="styleOpacity" type="range" min="0" max="1" step="0.05" value="1" /></div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px;">
          <button id="modalCancel" class="btn secondary">Cancel</button>
          <button id="modalSave" class="btn">Save</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ====== CONFIG ====== */
    const APPS_SCRIPT_URL = 'REPLACE_WITH_YOUR_APPS_SCRIPT_URL'; // <-- ganti jika mau upload ke Drive
    // Untuk testing cepat: path file GPX yang sudah kamu upload di sesi ini:
    const UPLOADED_GPX_PATH = '/mnt/data/Rangkum Langkimat.gpx'; // <-- gunakan ini untuk load cepat (server akan transform ke URL)

    /* default palette (ArcGIS-like) */
    const DEFAULT_STYLE = {
      trackLine: '#d35400',
      trackLineOutline: '#8e2b00',
      waypoint: '#1f78b4',
      polygonFill: '#f6e6d8',
      polygonOutline: '#d98b3a'
    };

    /* ====== Map & basemap helpers ====== */
    const basemapDefs = {
      osm: {
        id: 'basemap',
        tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
        attribution: '© OpenStreetMap contributors'
      },
      terrain: {
        id: 'basemap',
        tiles: ['https://stamen-tiles.a.ssl.fastly.net/terrain/{z}/{x}/{y}.jpg'],
        attribution: 'Terrain tiles by Stamen'
      },
      satellite: {
        id: 'basemap',
        tiles: ['https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'],
        attribution: 'Esri World Imagery'
      },
      light: {
        id: 'basemap',
        tiles: ['https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png'],
        attribution: 'Carto Light'
      },
      dark: {
        id: 'basemap',
        tiles: ['https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png'],
        attribution: 'Carto Dark'
      }
    };

    // Initial style uses OSM raster
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        sources: {
          basemap: {
            type: 'raster',
            tiles: basemapDefs.osm.tiles,
            tileSize: 256,
            attribution: basemapDefs.osm.attribution
          }
        },
        layers: [{ id: 'basemap-layer', type: 'raster', source: 'basemap' }]
      },
      center: [101.45, -0.45],
      zoom: 11
    });

    map.addControl(new maplibregl.NavigationControl(), 'top-right');
    map.addControl(new maplibregl.ScaleControl({maxWidth:200, unit:'metric'}), 'bottom-right');

    /* ====== Application state ====== */
    const state = {
      layers: [], // each: {id, name, type, geojson, visible, style: {color,width,opacity,radius}}
      nextId: 1
    };

    /* ====== Utility: rebuild all layers according to state order ====== */
    function rebuildAllLayers() {
      // remove all app layers & sources first
      // the layer ids we use are 'layer-{id}-...' ; remove them all
      // Note: keep basemap layers intact.
      const suffixes = ['-outline','-line','-symbol','-fill'];
      state.layers.forEach(l => {
        const base = 'layer-' + l.id;
        suffixes.forEach(s => {
          const lid = base + s;
          if (map.getLayer(lid)) try { map.removeLayer(lid); } catch(e){}
        });
        if (map.getSource(base)) try { map.removeSource(base); } catch(e){}
      });

      // add in order
      state.layers.forEach(l => {
        addLayerToMap(l, /*skipSourceCheck=*/false);
      });

      // refresh UI
      refreshLayerList();
      refreshLegend();
    }

    /* ====== Add single layer to map (safe) ====== */
    function addLayerToMap(layerObj, skipSourceCheck=false) {
      const id = 'layer-' + layerObj.id;

      // Ensure unique source
      if (map.getSource(id)) {
        // update source data
        map.getSource(id).setData(layerObj.geojson);
      } else {
        map.addSource(id, { type: 'geojson', data: layerObj.geojson });
      }

      // Default style values if absent
      const style = layerObj.style = layerObj.style || {};

      if (layerObj.type === 'track') {
        const outlineId = id + '-outline';
        const lineId = id + '-line';
        // outline: support LineString/MultiLineString
        if (!map.getLayer(outlineId)) {
          map.addLayer({
            id: outlineId,
            type: 'line',
            source: id,
            layout: { 'line-join': 'round', 'line-cap': 'round' },
            paint: {
              'line-color': style.outlineColor || style.color || DEFAULT_STYLE.trackLineOutline,
              'line-width': style.outlineWidth || (style.width ? Math.max(3, style.width+2) : 6),
              'line-opacity': typeof style.opacity === 'number' ? style.opacity : 0.9
            },
            filter: ["in", ["geometry-type"], ["literal", ["LineString", "MultiLineString"]]]
          });
        }
        if (!map.getLayer(lineId)) {
          map.addLayer({
            id: lineId,
            type: 'line',
            source: id,
            layout: { 'line-join': 'round', 'line-cap': 'round' },
            paint: {
              'line-color': style.color || DEFAULT_STYLE.trackLine,
              'line-width': style.width || 3,
              'line-opacity': typeof style.opacity === 'number' ? style.opacity : 1.0
            },
            filter: ["in", ["geometry-type"], ["literal", ["LineString", "MultiLineString"]]]
          });
        }
      } else if (layerObj.type === 'point') {
        const symbolId = id + '-symbol';
        if (!map.getLayer(symbolId)) {
          map.addLayer({
            id: symbolId,
            type: 'circle',
            source: id,
            paint: {
              'circle-radius': layerObj.style && layerObj.style.radius ? layerObj.style.radius : 6,
              'circle-color': layerObj.style && layerObj.style.color ? layerObj.style.color : DEFAULT_STYLE.waypoint,
              'circle-stroke-color': '#fff',
              'circle-stroke-width': 1,
              'circle-opacity': typeof layerObj.style && layerObj.style.opacity === 'number' ? layerObj.style.opacity : 1
            },
            filter: ["==", ["geometry-type"], "Point"]
          });
        }
      } else if (layerObj.type === 'polygon') {
        const fillId = id + '-fill';
        const outlineId = id + '-outline';
        if (!map.getLayer(fillId)) {
          map.addLayer({
            id: fillId,
            type: 'fill',
            source: id,
            paint: {
              'fill-color': layerObj.style && layerObj.style.color ? layerObj.style.color : DEFAULT_STYLE.polygonFill,
              'fill-opacity': typeof layerObj.style && layerObj.style.opacity === 'number' ? layerObj.style.opacity : 0.6
            }
          });
        }
        if (!map.getLayer(outlineId)) {
          map.addLayer({
            id: outlineId,
            type: 'line',
            source: id,
            paint: {
              'line-color': layerObj.style && layerObj.style.outlineColor ? layerObj.style.outlineColor : DEFAULT_STYLE.polygonOutline,
              'line-width': layerObj.style && layerObj.style.outlineWidth ? layerObj.style.outlineWidth : 2
            }
          });
        }
      }

      // set visibility per layerObj.visible
      toggleLayerVisibility(layerObj);
      // add click handlers (safe check)
      addClickHandlersForLayer(layerObj);
    }

    function addClickHandlersForLayer(layerObj) {
      const base = 'layer-' + layerObj.id;
      const symbolId = base + '-symbol';
      const lineId = base + '-line';

      if (map.getLayer(symbolId)) {
        map.off('click', symbolId, handleFeatureClick);
        map.on('click', symbolId, handleFeatureClick);
      }
      if (map.getLayer(lineId)) {
        map.off('click', lineId, handleFeatureClick);
        map.on('click', lineId, handleFeatureClick);
      }
    }

    function handleFeatureClick(e) {
      const props = e.features && e.features[0] && e.features[0].properties ? e.features[0].properties : {};
      new maplibregl.Popup()
        .setLngLat(e.lngLat)
        .setHTML('<pre style="font-size:12px">' + JSON.stringify(props, null, 2) + '</pre>')
        .addTo(map);
    }

    /* ====== Layer list UI ====== */
    function refreshLayerList() {
      const list = document.getElementById('layerList');
      list.innerHTML = '';
      state.layers.slice().reverse().forEach(layer => {
        // display topmost first
        const el = document.createElement('div');
        el.className = 'layer-item';
        const left = document.createElement('div'); left.className = 'layer-left';
        const cb = document.createElement('input'); cb.type='checkbox'; cb.checked = layer.visible; cb.dataset.id = layer.id;
        cb.onchange = () => { layer.visible = cb.checked; toggleLayerVisibility(layer); refreshLegend(); };
        const title = document.createElement('div'); title.innerHTML = `<b>${layer.name}</b><div class="small">${layer.type}</div>`;
        left.appendChild(cb); left.appendChild(title);

        const right = document.createElement('div'); right.className='layer-actions';
        const btnStyle = document.createElement('button'); btnStyle.className='btn secondary'; btnStyle.textContent='Style'; btnStyle.onclick = () => openStyleModal(layer.id);
        const btnUp = document.createElement('button'); btnUp.className='btn'; btnUp.textContent='▲'; btnUp.title='Move up'; btnUp.onclick = () => moveLayer(layer.id, -1);
        const btnDown = document.createElement('button'); btnDown.className='btn'; btnDown.textContent='▼'; btnDown.title='Move down'; btnDown.onclick = () => moveLayer(layer.id, 1);
        const btnZoom = document.createElement('button'); btnZoom.className='btn secondary'; btnZoom.textContent='Zoom'; btnZoom.onclick = () => zoomToGeoJSON(layer.geojson);
        const btnExport = document.createElement('button'); btnExport.className='btn secondary'; btnExport.textContent='Export'; btnExport.onclick = () => exportLayerGeoJSON(layer);
        const btnConvert = document.createElement('button'); btnConvert.className='btn secondary'; btnConvert.textContent='Convert'; btnConvert.title='Convert track→polygon if closed'; btnConvert.onclick = () => convertTrackToPolygon(layer.id);
        const btnRemove = document.createElement('button'); btnRemove.className='btn warn'; btnRemove.textContent='Remove'; btnRemove.onclick = () => { removeLayer(layer.id); };

        right.appendChild(btnStyle);
        right.appendChild(btnUp);
        right.appendChild(btnDown);
        right.appendChild(btnZoom);
        right.appendChild(btnExport);
        right.appendChild(btnConvert);
        right.appendChild(btnRemove);

        el.appendChild(left);
        el.appendChild(right);
        list.appendChild(el);
      });
    }

    function refreshLegend(){
      const node = document.getElementById('legendItems');
      node.innerHTML = '';
      state.layers.forEach(l => {
        const div = document.createElement('div');
        const sample = document.createElement('span');
        sample.style.display='inline-block'; sample.style.width='18px'; sample.style.height='12px'; sample.style.marginRight='8px';
        const color = (l.style && l.style.color) || (l.type === 'track' ? DEFAULT_STYLE.trackLine : l.type==='point' ? DEFAULT_STYLE.waypoint : DEFAULT_STYLE.polygonFill);
        sample.style.background = color;
        div.innerHTML = `<b>${l.name}</b> <span class="small">(${l.type})</span>`;
        div.prepend(sample);
        node.appendChild(div);
      });
    }

    /* ====== Toggle visibility ====== */
    function toggleLayerVisibility(layer) {
      const id = 'layer-' + layer.id;
      const visible = layer.visible;
      const suffixes = ['-outline','-line','-symbol','-fill'];
      suffixes.forEach(s => {
        const lid = id + s;
        if (map.getLayer(lid)) {
          map.setLayoutProperty(lid, 'visibility', visible ? 'visible' : 'none');
        }
      });
    }

    /* ====== Move layer in state order (-1 up, +1 down) ====== */
    function moveLayer(id, delta) {
      const idx = state.layers.findIndex(l => l.id === id);
      if (idx === -1) return;
      const newIdx = idx + delta;
      if (newIdx < 0 || newIdx >= state.layers.length) return;
      // swap
      [state.layers[idx], state.layers[newIdx]] = [state.layers[newIdx], state.layers[idx]];
      rebuildAllLayers();
    }

    function removeLayer(id) {
      const idx = state.layers.findIndex(l => l.id === id);
      if (idx === -1) return;
      const base = 'layer-' + id;
      ['-outline','-line','-symbol','-fill'].forEach(s => {
        const lid = base + s;
        if (map.getLayer(lid)) try { map.removeLayer(lid); } catch(e){}
      });
      if (map.getSource(base)) try { map.removeSource(base); } catch(e){}
      state.layers.splice(idx,1);
      refreshLayerList();
      refreshLegend();
    }

    /* ====== Zoom to geojson extent ====== */
    function zoomToGeoJSON(geojson) {
      if (!geojson || !geojson.features || geojson.features.length===0) return;
      const coords = [];
      geojson.features.forEach(f => {
        const geom = f.geometry;
        if (!geom) return;
        if (geom.type === 'Point') coords.push(geom.coordinates);
        else if (geom.type === 'LineString') coords.push(...geom.coordinates);
        else if (geom.type === 'MultiLineString') geom.coordinates.forEach(a => coords.push(...a));
        else if (geom.type === 'Polygon') geom.coordinates.flat().forEach(c=>coords.push(c));
        else if (geom.type === 'MultiPolygon') geom.coordinates.flat(2).forEach(c=>coords.push(c));
      });
      if (coords.length === 0) return;
      const lats = coords.map(c => c[1]);
      const lngs = coords.map(c => c[0]);
      const minLat = Math.min(...lats), maxLat = Math.max(...lats);
      const minLng = Math.min(...lngs), maxLng = Math.max(...lngs);
      map.fitBounds([[minLng, minLat],[maxLng, maxLat]], {padding:40});
    }

    /* ====== File handling & parsing ====== */
    document.getElementById('addLocal').onclick = async () => {
      const input = document.getElementById('fileInput');
      if (!input.files || input.files.length === 0) { alert('Pilih file dulu'); return; }
      const file = input.files[0];
      await handleFileRead(file, {upload:false});
    };

    document.getElementById('uploadToDrive').onclick = async () => {
      const input = document.getElementById('fileInput');
      if (!input.files || input.files.length === 0) { alert('Pilih file dulu'); return; }
      document.getElementById('uploadStatus').textContent = 'Uploading...';
      const file = input.files[0];
      try {
        const res = await uploadToAppsScript(file);
        document.getElementById('uploadStatus').textContent = 'Uploaded: ' + res.name;
        // fetch content back via apps script endpoint
        const contentResp = await fetch(res.url);
        const text = await contentResp.text();
        await parseAndAddFileContent(text, file.name);
      } catch (err) {
        document.getElementById('uploadStatus').textContent = 'Error: ' + err.message;
      }
    };

    // quick loader for the GPX you uploaded (path provided by session)
    document.getElementById('loadUploadedGPX').onclick = async () => {
      try {
        const resp = await fetch(UPLOADED_GPX_PATH);
        if (!resp.ok) throw new Error('Fetch failed: ' + resp.status);
        const text = await resp.text();
        await parseAndAddFileContent(text, 'Rangkum Langkimat.gpx');
      } catch (err) {
        alert('Gagal load uploaded GPX: ' + err.message + '\n(If running locally, ensure your environment serves that path or transform the path to a URL.)');
      }
    };

    async function uploadToAppsScript(file) {
      const form = new FormData();
      form.append('filename', file.name);
      form.append('contentType', file.type || 'application/octet-stream');
      const arr = await file.arrayBuffer();
      const b64 = arrayBufferToBase64(arr);
      form.append('b64', b64);

      const resp = await fetch(APPS_SCRIPT_URL, { method: 'POST', body: form });
      if (!resp.ok) throw new Error('Upload failed: ' + resp.status);
      const j = await resp.json();
      if (j.error) throw new Error(j.error);
      return j; // contains id, name, url
    }

    function arrayBufferToBase64(buffer) {
      let binary = '';
      const bytes = new Uint8Array(buffer);
      const len = bytes.byteLength;
      for (let i = 0; i < len; i++) binary += String.fromCharCode(bytes[i]);
      return btoa(binary);
    }

    async function handleFileRead(file, opts={upload:false}) {
      const text = await file.text();
      await parseAndAddFileContent(text, file.name);
    }

    async function parseAndAddFileContent(text, filename) {
      const name = filename.toLowerCase();
      let geojson = null;
      if (name.endsWith('.gpx') || text.trim().startsWith('<?xml')) {
        const parser = new DOMParser();
        const xml = parser.parseFromString(text, 'application/xml');
        geojson = toGeoJSON.gpx(xml);
      } else if (name.endsWith('.geojson') || name.endsWith('.json')) {
        geojson = JSON.parse(text);
      } else {
        alert('Unsupported file type. Use GPX or GeoJSON.');
        return;
      }

      // Split into feature collections
      const points = {type:'FeatureCollection', features: []};
      const lines = {type:'FeatureCollection', features: []};
      const polygons = {type:'FeatureCollection', features: []};

      geojson.features.forEach(f => {
        if (!f.geometry) return;
        const t = f.geometry.type;
        if (t === 'Point' || t === 'MultiPoint') points.features.push(f);
        else if (t === 'LineString' || t === 'MultiLineString') {
          const treatAsPoly = document.getElementById('treatTrackAsPolygon').checked;
          if (treatAsPoly && t === 'LineString') {
            const coords = f.geometry.coordinates;
            if (coords.length >= 3) {
              const first = coords[0], last = coords[coords.length-1];
              if (first[0] === last[0] && first[1] === last[1]) {
                polygons.features.push({type:'Feature', properties: f.properties||{}, geometry: { type: 'Polygon', coordinates: [coords] }});
                return;
              }
            }
          }
          lines.features.push(f);
        } else if (t === 'Polygon' || t === 'MultiPolygon') polygons.features.push(f);
      });

      // Add layers to state
      if (lines.features.length) addNewLayer(lines, 'track', filename + ' — tracks');
      if (points.features.length) addNewLayer(points, 'point', filename + ' — waypoints');
      if (polygons.features.length) addNewLayer(polygons, 'polygon', filename + ' — polygons');

      refreshLayerList();
      refreshLegend();
      if (document.getElementById('autoZoom').checked) {
        const combined = {type:'FeatureCollection', features: []};
        combined.features.push(...lines.features, ...points.features, ...polygons.features);
        zoomToGeoJSON(combined);
      }
    }

    function addNewLayer(geojson, type, name) {
      const layer = {
        id: state.nextId++,
        name,
        type,
        geojson,
        visible: true,
        style: {
          color: type==='track' ? DEFAULT_STYLE.trackLine : type==='point' ? DEFAULT_STYLE.waypoint : DEFAULT_STYLE.polygonFill,
          width: type==='track' ? 3 : undefined,
          opacity: 1,
          radius: type==='point' ? 6 : undefined
        }
      };
      state.layers.push(layer);
      addLayerToMap(layer);
      refreshLayerList();
      refreshLegend();
    }

    /* ====== Export single layer ====== */
    function exportLayerGeoJSON(layer) {
      const text = JSON.stringify(layer.geojson, null, 2);
      const blob = new Blob([text], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = layer.name.replace(/\s+/g,'_') + '.geojson'; a.click();
      URL.revokeObjectURL(url);
    }

    /* ====== Convert track -> polygon (if closed) ====== */
    function convertTrackToPolygon(layerId) {
      const layer = state.layers.find(l => l.id === layerId);
      if (!layer || layer.type !== 'track') { alert('Layer bukan track'); return; }
      // attempt conversion for each LineString feature that's closed
      const polygons = { type:'FeatureCollection', features: [] };
      layer.geojson.features.forEach(f => {
        const g = f.geometry;
        if (!g) return;
        if (g.type === 'LineString') {
          const coords = g.coordinates;
          if (coords.length >=3) {
            const first = coords[0], last = coords[coords.length-1];
            if (first[0] === last[0] && first[1] === last[1]) {
              polygons.features.push({type:'Feature', properties: f.properties || {}, geometry:{type:'Polygon', coordinates:[coords]}});
            }
          }
        } else if (g.type === 'MultiLineString') {
          // try each ring
          g.coordinates.forEach(arr => {
            if (arr.length>=3) {
              const first = arr[0], last = arr[arr.length-1];
              if (first[0]===last[0] && first[1]===last[1]) {
                polygons.features.push({type:'Feature', properties: f.properties || {}, geometry:{type:'Polygon', coordinates:[arr]}});
              }
            }
          });
        }
      });
      if (polygons.features.length===0) { alert('Tidak ada track tertutup untuk dikonversi'); return; }
      addNewLayer(polygons, 'polygon', layer.name + ' — converted polygons');
    }

    /* ====== Modal style editor (option C: popup modal) ====== */
    const modalBackdrop = document.getElementById('modalBackdrop');
    const styleColor = document.getElementById('styleColor');
    const styleOpacity = document.getElementById('styleOpacity');
    const lineWidth = document.getElementById('lineWidth');
    const pointRadius = document.getElementById('pointRadius');
    let editingLayerId = null;

    function openStyleModal(layerId) {
      const layer = state.layers.find(l => l.id === layerId);
      if (!layer) return;
      editingLayerId = layerId;
      document.getElementById('modalTitle').textContent = 'Edit: ' + layer.name;
      styleColor.value = layer.style && layer.style.color ? rgbToHex(layer.style.color) : '#ff0000';
      styleOpacity.value = (typeof layer.style.opacity === 'number') ? layer.style.opacity : 1;
      lineWidth.value = (layer.style && layer.style.width) ? layer.style.width : 3;
      pointRadius.value = (layer.style && layer.style.radius) ? layer.style.radius : 6;
      // show/hide controls based on type
      document.getElementById('lineOptions').style.display = layer.type==='track' || layer.type==='polygon' ? 'flex' : 'none';
      document.getElementById('radiusOptions').style.display = layer.type==='point' ? 'flex' : 'none';
      modalBackdrop.style.display = 'flex';
      modalBackdrop.setAttribute('aria-hidden','false');
    }

    document.getElementById('modalCancel').onclick = () => {
      modalBackdrop.style.display = 'none';
      modalBackdrop.setAttribute('aria-hidden','true');
      editingLayerId = null;
    };

    document.getElementById('modalSave').onclick = () => {
      if (!editingLayerId) return;
      const layer = state.layers.find(l => l.id === editingLayerId);
      if (!layer) return;
      // save style
      layer.style = layer.style || {};
      layer.style.color = styleColor.value;
      layer.style.opacity = parseFloat(styleOpacity.value);
      if (layer.type === 'track') layer.style.width = parseInt(lineWidth.value,10);
      if (layer.type === 'point') layer.style.radius = parseInt(pointRadius.value,10);
      // polygon uses color & opacity; for polygon outline we keep defaults
      // rebuild layers so paint props update
      rebuildAllLayers();
      modalBackdrop.style.display = 'none';
      modalBackdrop.setAttribute('aria-hidden','true');
      editingLayerId = null;
    };

    function rgbToHex(input) {
      // if already hex, return
      if (!input) return '#000000';
      if (input[0] === '#') return input;
      // try parse rgb(...) style
      const m = input.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return '#000000';
      const r = parseInt(m[1]), g = parseInt(m[2]), b = parseInt(m[3]);
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    /* ====== Export / Save state ====== */
    document.getElementById('exportGeoJSON').onclick = () => {
      const all = { type:'FeatureCollection', features: [] };
      state.layers.forEach(l => all.features.push(...l.geojson.features));
      const text = JSON.stringify(all, null, 2);
      const blob = new Blob([text], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'export_all.geojson'; a.click();
      URL.revokeObjectURL(url);
    };

    document.getElementById('exportState').onclick = () => {
      const text = JSON.stringify(state, null, 2);
      const blob = new Blob([text], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'map_state.json'; a.click();
      URL.revokeObjectURL(url);
    };

    /* ====== Layer editing helpers ====== */
    function exportLayerGeoJSON(layer) {
      const text = JSON.stringify(layer.geojson, null, 2);
      const blob = new Blob([text], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = layer.name.replace(/\s+/g,'_') + '.geojson'; a.click();
      URL.revokeObjectURL(url);
    }

    /* ====== Basemap switching (replace basemap source & layer) ====== */
    document.getElementById('basemapSelect').onchange = (e) => {
      const key = e.target.value;
      switchBasemap(key);
    };

    function switchBasemap(key) {
      const def = basemapDefs[key] || basemapDefs.osm;
      // remove existing basemap layer/source if present
      if (map.getLayer('basemap-layer')) try { map.removeLayer('basemap-layer'); } catch(e){}
      if (map.getSource('basemap')) try { map.removeSource('basemap'); } catch(e){}
      map.addSource('basemap', { type: 'raster', tiles: def.tiles, tileSize: 256, attribution: def.attribution });
      map.addLayer({ id: 'basemap-layer', type: 'raster', source: 'basemap' }, /*before*/ undefined);
      // then rebuild app layers to ensure they sit above basemap
      rebuildAllLayers();
    }

    /* ====== Utility: convert colors that might be non-hex to hex on save ====== */
    function ensureLayerPaints(layer){
      if (!layer.style) layer.style = {};
      if (!layer.style.color) layer.style.color = DEFAULT_STYLE.trackLine;
    }

    /* ====== Initialization ====== */
    refreshLayerList();

    /* ====== Notes about environment & uploaded GPX path ======
      - Quick-load button uses path: /mnt/data/Rangkum Langkimat.gpx
      - If running this file on a server that can serve that local path (or your environment will translate it),
        the quick-load should work. Otherwise, upload the file via the UI to Google Drive and load from there.
    ========================================================= */

  </script>
</body>
</html>
