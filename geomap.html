<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <title>Peta Leaflet — GPX/GeoJSON Upload & PDF Export (Areal-only)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- toGeoJSON (GPX -> GeoJSON) -->
  <script src="https://unpkg.com/@mapbox/togeojson@0.16.2/togeojson.js"></script>

  <style>
    html,body,#map { height: 100%; margin: 0; padding: 0; font-family: Inter, Arial, sans-serif; }
    #app { display: grid; grid-template-columns: 380px 1fr; height: 100vh; }
    #sidebar { background:#fff; border-right:1px solid #e6e6e6; padding:12px; box-sizing:border-box; overflow:auto;}
    h2 { margin:6px 0 12px; font-size:18px; }
    .control { margin-bottom:12px; }
    #map { position: relative; }

    .layer-item { display:flex;align-items:center;justify-content:space-between;padding:8px;border:1px solid #eee;border-radius:6px;margin-bottom:6px;}
    .layer-left { display:flex; gap:8px; align-items:center;}
    .btn { background:#2b6cb0;color:#fff;padding:6px 8px;border-radius:6px;border:none;cursor:pointer;}
    .btn.secondary { background:#edf2f7;color:#111; }
    .btn.warn { background:#d9534f; }
    input[type=file] { display:block; margin-top:8px; }
    .small { font-size:12px;color:#666; }
    label { display:block; margin-bottom:6px; font-weight:600; }

    /* Modal */
    .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.4); display:none; align-items:center; justify-content:center; z-index:9999;}
    .modal { background:#fff; width:440px; border-radius:8px; padding:16px; box-shadow:0 8px 24px rgba(0,0,0,0.2); }
    .modal h3 { margin:0 0 8px; font-size:16px; }
    .form-row { margin:8px 0; display:flex; align-items:center; gap:8px; justify-content:space-between; }
    .form-row input[type="range"] { width:200px; }
    .legend { margin-top:12px; border-top:1px solid #eee; padding-top:8px; font-size:13px; }
    .basemap-select { width:100%; padding:6px; border-radius:6px; border:1px solid #ddd; }
    .layer-actions { display:flex; gap:6px; }
    .muted { color:#666; font-size:12px; }

    /* North arrow overlay */
    .north-arrow {
      position: absolute;
      right: 12px;
      top: 12px;
      width: 56px;
      height: 56px;
      z-index: 600;
      pointer-events: none;
      display:flex;align-items:center;justify-content:center;
      background: rgba(255,255,255,0.85);
      border-radius:6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      font-weight:700;
    }

    /* print button */
    #printMapBtn { margin-top:8px; display:block; }

    /* grid labels (on-screen optional) */
    .grid-label { position:absolute; background:rgba(255,255,255,0.8); padding:2px 4px; font-size:11px; border-radius:2px; pointer-events:none; z-index:500; }
  </style>
</head>
<body>
  <div id="app">
    <aside id="sidebar">
      <h2>Peta — Leaflet (A)</h2>

      <div class="control">
        <label>Basemap</label>
        <select id="basemapSelect" class="basemap-select">
          <option value="osm">OpenStreetMap</option>
          <option value="terrain">Stamen Terrain</option>
          <option value="satellite">Esri WorldImagery</option>
          <option value="carto_light">Carto Light</option>
          <option value="carto_dark">Carto Dark</option>
        </select>
      </div>

      <div class="control">
        <label>Upload file (GPX or GeoJSON)</label>
        <input id="fileInput" type="file" accept=".gpx,.xml,.geojson,.json" />
        <div style="margin-top:8px;">
          <button id="uploadToDrive" class="btn">Upload → Google Drive</button>
          <button id="addLocal" class="btn secondary">Load locally (tanpa upload)</button>
          <button id="loadUploadedGPX" class="btn secondary" title="Load GPX yang sudah diupload di session ini">Load: Rangkum Langkimat.gpx</button>
        </div>
        <div id="uploadStatus" class="small" style="margin-top:8px;"></div>
      </div>

      <div class="control">
        <label>Rendering & Convert options</label>
        <input type="checkbox" id="treatTrackAsPolygon" /> <label for="treatTrackAsPolygon" style="display:inline;font-weight:normal">Treat closed tracks as polygon</label><br>
        <input type="checkbox" id="simplifyOnConvert" /> <label for="simplifyOnConvert" style="display:inline;font-weight:normal">Simplify converted polygons</label><br>
        <label class="muted">Simplify tolerance (m) — higher = more simplification</label>
        <input id="simplifyTolerance" type="range" min="0" max="50" step="1" value="5" />
        <div class="muted">Auto zoom to uploaded data <input type="checkbox" id="autoZoom" checked style="margin-left:8px"/></div>
      </div>

      <div class="control">
        <label>Layers</label>
        <div id="layerList"></div>
      </div>

      <div class="control">
        <label>Export / Print</label>
        <div style="display:flex; gap:8px; flex-direction:column;">
          <button id="printMapBtn" class="btn">Print Map (PDF)</button>
          <button id="exportGeoJSON" class="btn secondary">Export All GeoJSON</button>
          <button id="exportState" class="btn secondary">Download State</button>
        </div>
      </div>

      <div class="small legend" id="legend">
        <b>Legend:</b>
        <div id="legendItems"></div>
      </div>
    </aside>

    <div id="map"></div>
    <div class="north-arrow" id="northArrow" aria-hidden="true">
      <!-- simple stylized arrow -->
      <svg width="36" height="36" viewBox="0 0 24 24" aria-hidden="true">
        <polygon points="12,2 4,22 12,18 20,22" fill="#111"/>
        <text x="12" y="10" fill="#fff" font-size="6" font-weight="700" text-anchor="middle">N</text>
      </svg>
    </div>
  </div>

  <!-- modal style editor -->
  <div id="modalBackdrop" class="modal-backdrop" role="dialog" aria-hidden="true">
    <div class="modal" role="document">
      <h3 id="modalTitle">Edit Layer</h3>
      <div id="modalBody">
        <div class="form-row"><label>Color</label><input type="color" id="styleColor" /></div>
        <div class="form-row" id="lineOptions"><label>Line width</label><input id="lineWidth" type="range" min="1" max="12" value="3" /></div>
        <div class="form-row" id="radiusOptions" style="display:none"><label>Radius</label><input id="pointRadius" type="range" min="1" max="20" value="6" /></div>
        <div class="form-row"><label>Opacity</label><input id="styleOpacity" type="range" min="0" max="1" step="0.05" value="1" /></div>
        <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px;">
          <button id="modalCancel" class="btn secondary">Cancel</button>
          <button id="modalSave" class="btn">Save</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  /* ====== CONFIG ====== */
  const APPS_SCRIPT_URL = 'REPLACE_WITH_YOUR_APPS_SCRIPT_URL';
  // path to sample GPX already uploaded to session: (tool will transform path to URL)
  const UPLOADED_GPX_PATH = '/mnt/data/Rangkum Langkimat.gpx';

  const DEFAULT_STYLE = {
    trackLine: '#d35400',
    waypoint: '#1f78b4',
    polygonFill: '#f6e6d8',
    polygonOutline: '#d98b3a'
  };

  // expose global state for export functions
  window.state = { layers: [], nextId: 1 };

  /* ====== Init Leaflet map ====== */
  const map = L.map('map', { preferCanvas: true }).setView([-0.45, 101.45], 11);
  window.map = map; // for global usage

  // basemap definitions
  const basemapDefs = {
    osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '© OpenStreetMap contributors' }),
    terrain: L.tileLayer('https://stamen-tiles.a.ssl.fastly.net/terrain/{z}/{x}/{y}.jpg', { maxZoom: 18, attribution: 'Stamen Terrain' }),
    satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { maxZoom: 18, attribution: 'Esri World Imagery' }),
    carto_light: L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', { maxZoom: 19, attribution: 'Carto Light' }),
    carto_dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', { maxZoom: 19, attribution: 'Carto Dark' })
  };

  // keep track of current base layer and provide switcher
  let currentBase = basemapDefs.osm.addTo(map);
  function switchBasemap(key){
    try{
      if (currentBase) map.removeLayer(currentBase);
    } catch(e){}
    const next = basemapDefs[key] || basemapDefs.osm;
    currentBase = next.addTo(map);
  }
  document.getElementById('basemapSelect').value = 'osm';
  document.getElementById('basemapSelect').onchange = (e) => switchBasemap(e.target.value);

  L.control.scale({ metric: true, imperial: false }).addTo(map);

  /* ====== Utility: simplify RDP (coords: [lng,lat]) ====== */
  function simplifyRDP(coords, toleranceMeters) {
    if (!coords || coords.length < 3) return coords.slice();
    const meanLat = coords.reduce((s,c)=>s + c[1],0)/coords.length;
    const meterToDeg = 1 / (111320 * Math.cos(meanLat * Math.PI/180));
    const eps = toleranceMeters * meterToDeg;
    function sqDist(a,b){ const dx=a[0]-b[0], dy=a[1]-b[1]; return dx*dx + dy*dy; }
    function distToSeg2(p, v, w){
      const l2 = sqDist(v,w); if (l2===0) return sqDist(p,v);
      let t = ((p[0]-v[0])*(w[0]-v[0]) + (p[1]-v[1])*(w[1]-v[1]))/l2;
      t = Math.max(0, Math.min(1, t));
      const proj = [ v[0] + t*(w[0]-v[0]), v[1] + t*(w[1]-v[1]) ];
      return sqDist(p, proj);
    }
    function rdp(points, eps){
      const n = points.length;
      const keep = new Array(n).fill(false);
      keep[0] = keep[n-1] = true;
      const stack = [[0,n-1]];
      while(stack.length){
        const [i,j] = stack.pop();
        let maxd=0, idx=-1;
        for(let k=i+1;k<j;k++){
          const d = distToSeg2(points[k], points[i], points[j]);
          if (d > maxd){ maxd = d; idx = k; }
        }
        if (Math.sqrt(maxd) > eps){
          keep[idx]=true;
          stack.push([i,idx]); stack.push([idx,j]);
        }
      }
      const res = [];
      for(let i=0;i<n;i++) if (keep[i]) res.push(points[i]);
      return res;
    }
    return rdp(coords, eps);
  }

  /* ====== Layer management (Leaflet GeoJSON layers) ====== */
  function addNewLayer(geojson, type, name){
    const id = window.state.nextId++;
    const layerObj = {
      id, name, type, geojson,
      visible: true,
      style: {
        color: type==='track' ? DEFAULT_STYLE.trackLine : type==='point' ? DEFAULT_STYLE.waypoint : DEFAULT_STYLE.polygonFill,
        width: type==='track' ? 3 : undefined,
        opacity: 1,
        radius: type==='point' ? 6 : undefined
      },
      leafletLayer: null
    };
    // create leaflet layer
    const opts = {};
    if (type === 'point'){
      opts.pointToLayer = (f,latlng) => L.circleMarker(latlng, { radius: layerObj.style.radius, color: layerObj.style.color, weight:1, fillOpacity: layerObj.style.opacity, fillColor: layerObj.style.color });
    } else {
      opts.style = (f) => {
        if (type === 'polygon') return { color: layerObj.style.color, weight: layerObj.style.width || 2, fillColor: layerObj.style.color, fillOpacity: layerObj.style.opacity || 0.6 };
        return { color: layerObj.style.color, weight: layerObj.style.width || 3, opacity: layerObj.style.opacity || 1 };
      };
    }
    const leafletLayer = L.geoJSON(geojson, opts).addTo(map);
    layerObj.leafletLayer = leafletLayer;
    window.state.layers.push(layerObj);
    refreshLayerList(); refreshLegend();
    return layerObj;
  }

  function removeLayerById(id){
    const idx = window.state.layers.findIndex(l=>l.id===id);
    if (idx===-1) return;
    const l = window.state.layers[idx];
    if (l.leafletLayer) map.removeLayer(l.leafletLayer);
    window.state.layers.splice(idx,1);
    refreshLayerList(); refreshLegend();
  }

  function rebuildAllLayers(){
    // remove all
    window.state.layers.forEach(l => { if (l.leafletLayer) map.removeLayer(l.leafletLayer); l.leafletLayer = null; });
    // re-add
    window.state.layers.forEach(l => {
      const opts = {};
      if (l.type === 'point') opts.pointToLayer = (f,latlng) => L.circleMarker(latlng, { radius: l.style.radius, color: l.style.color, weight:1, fillOpacity: l.style.opacity, fillColor: l.style.color });
      else opts.style = (f) => l.type==='polygon' ? { color: l.style.color, weight: l.style.width || 2, fillColor: l.style.color, fillOpacity: l.style.opacity || 0.6 } : { color: l.style.color, weight: l.style.width || 3, opacity: l.style.opacity || 1 };
      l.leafletLayer = L.geoJSON(l.geojson, opts).addTo(map);
    });
    refreshLayerList(); refreshLegend();
  }

  /* ====== UI: layer list & legend ====== */
  function refreshLayerList(){
    const list = document.getElementById('layerList');
    list.innerHTML = '';
    window.state.layers.slice().reverse().forEach(layer => {
      const el = document.createElement('div'); el.className='layer-item';
      const left = document.createElement('div'); left.className='layer-left';
      const cb = document.createElement('input'); cb.type='checkbox'; cb.checked = layer.visible; cb.dataset.id = layer.id;
      cb.onchange = () => { layer.visible = cb.checked; if (layer.leafletLayer) { if (cb.checked) map.addLayer(layer.leafletLayer); else map.removeLayer(layer.leafletLayer); } refreshLegend(); };
      const title = document.createElement('div'); title.innerHTML = `<b>${layer.name}</b><div class="small">${layer.type}</div>`;
      left.appendChild(cb); left.appendChild(title);

      const right = document.createElement('div'); right.className='layer-actions';
      const btnStyle = document.createElement('button'); btnStyle.className='btn secondary'; btnStyle.textContent='Style'; btnStyle.onclick = () => openStyleModal(layer.id);
      const btnUp = document.createElement('button'); btnUp.className='btn'; btnUp.textContent='▲'; btnUp.title='Move up'; btnUp.onclick = () => moveLayer(layer.id, -1);
      const btnDown = document.createElement('button'); btnDown.className='btn'; btnDown.textContent='▼'; btnDown.title='Move down'; btnDown.onclick = () => moveLayer(layer.id, 1);
      const btnZoom = document.createElement('button'); btnZoom.className='btn secondary'; btnZoom.textContent='Zoom'; btnZoom.onclick = () => { try{ map.fitBounds(layer.leafletLayer.getBounds()); }catch(e){} };
      const btnExport = document.createElement('button'); btnExport.className='btn secondary'; btnExport.textContent='Export'; btnExport.onclick = () => exportLayerGeoJSON(layer);
      const btnConvert = document.createElement('button'); btnConvert.className='btn secondary'; btnConvert.textContent='Convert'; btnConvert.title='Convert track→polygon if closed'; btnConvert.onclick = () => convertTrackToPolygon(layer.id);
      const btnRemove = document.createElement('button'); btnRemove.className='btn warn'; btnRemove.textContent='Remove'; btnRemove.onclick = () => removeLayerById(layer.id);

      right.appendChild(btnStyle);
      right.appendChild(btnUp);
      right.appendChild(btnDown);
      right.appendChild(btnZoom);
      right.appendChild(btnExport);
      right.appendChild(btnConvert);
      right.appendChild(btnRemove);

      el.appendChild(left); el.appendChild(right);
      list.appendChild(el);
    });
  }

  function refreshLegend(){
    const node = document.getElementById('legendItems');
    node.innerHTML = '';
    window.state.layers.forEach(l => {
      const div = document.createElement('div');
      const sample = document.createElement('span');
      sample.style.display='inline-block'; sample.style.width='18px'; sample.style.height='12px'; sample.style.marginRight='8px';
      const color = (l.style && l.style.color) || (l.type === 'track' ? DEFAULT_STYLE.trackLine : l.type==='point' ? DEFAULT_STYLE.waypoint : DEFAULT_STYLE.polygonFill);
      sample.style.background = color;
      div.innerHTML = `<b>${l.name}</b> <span class="small">(${l.type})</span>`;
      div.prepend(sample);
      node.appendChild(div);
    });
  }

  function moveLayer(id, delta){
    const idx = window.state.layers.findIndex(l=>l.id===id);
    if (idx===-1) return;
    const newIdx = idx + delta;
    if (newIdx < 0 || newIdx >= window.state.layers.length) return;
    [window.state.layers[idx], window.state.layers[newIdx]] = [window.state.layers[newIdx], window.state.layers[idx]];
    rebuildAllLayers();
  }

  function exportLayerGeoJSON(layer){
    const text = JSON.stringify(layer.geojson, null, 2);
    const blob = new Blob([text], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = layer.name.replace(/\s+/g,'_') + '.geojson'; a.click();
    URL.revokeObjectURL(url);
  }

  /* ====== File handling & parsing ====== */
  document.getElementById('addLocal').onclick = async () => {
    const input = document.getElementById('fileInput');
    if (!input.files || input.files.length === 0) { alert('Pilih file dulu'); return; }
    const file = input.files[0];
    const text = await file.text();
    await parseAndAddFileContent(text, file.name);
  };

  document.getElementById('uploadToDrive').onclick = async () => {
    const input = document.getElementById('fileInput');
    if (!input.files || input.files.length === 0) { alert('Pilih file dulu'); return; }
    document.getElementById('uploadStatus').textContent = 'Uploading...';
    const file = input.files[0];
    try {
      // simple upload via Apps Script (unchanged)
      const form = new FormData();
      form.append('filename', file.name);
      form.append('contentType', file.type || 'application/octet-stream');
      const arr = await file.arrayBuffer();
      const b64 = arrayBufferToBase64(arr);
      form.append('b64', b64);
      const resp = await fetch(APPS_SCRIPT_URL, { method: 'POST', body: form });
      if (!resp.ok) throw new Error('Upload failed: ' + resp.status);
      const j = await resp.json();
      if (j.error) throw new Error(j.error);
      document.getElementById('uploadStatus').textContent = 'Uploaded: ' + j.name;
      // try load content back if accessible
      if (j.url){
        const contentResp = await fetch(j.url);
        const text = await contentResp.text();
        await parseAndAddFileContent(text, file.name);
      }
    } catch (err){
      document.getElementById('uploadStatus').textContent = 'Error: ' + err.message;
    }
  };

  document.getElementById('loadUploadedGPX').onclick = async () => {
    try {
      const resp = await fetch(UPLOADED_GPX_PATH);
      if (!resp.ok) throw new Error('Fetch failed: ' + resp.status);
      const text = await resp.text();
      await parseAndAddFileContent(text, 'Rangkum Langkimat.gpx');
    } catch (err){
      alert('Gagal load uploaded GPX: ' + err.message + '\n(If running locally, ensure your environment serves that path.)');
    }
  };

  function arrayBufferToBase64(buffer) {
    let binary = '';
    const bytes = new Uint8Array(buffer);
    const len = bytes.byteLength;
    for (let i = 0; i < len; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }

  async function parseAndAddFileContent(text, filename){
    const name = filename.toLowerCase();
    let geojson = null;
    if (name.endsWith('.gpx') || text.trim().startsWith('<?xml')) {
      const parser = new DOMParser();
      const xml = parser.parseFromString(text, 'application/xml');
      geojson = toGeoJSON.gpx(xml);
    } else if (name.endsWith('.geojson') || name.endsWith('.json')) {
      geojson = JSON.parse(text);
    } else {
      alert('Unsupported file type. Use GPX or GeoJSON.');
      return;
    }

    // split features
    const points = { type:'FeatureCollection', features:[] };
    const lines = { type:'FeatureCollection', features:[] };
    const polygons = { type:'FeatureCollection', features:[] };

    geojson.features.forEach(f=>{
      if (!f.geometry) return;
      const t = f.geometry.type;
      if (t === 'Point' || t === 'MultiPoint') points.features.push(f);
      else if (t === 'LineString' || t === 'MultiLineString'){
        const treatAsPoly = document.getElementById('treatTrackAsPolygon').checked;
        if (treatAsPoly && t === 'LineString'){
          const coords = f.geometry.coordinates;
          if (coords.length >= 3 && isRingClosed(coords)){
            const ring = closeRing(coords);
            polygons.features.push({ type:'Feature', properties: f.properties||{}, geometry: { type:'Polygon', coordinates: [ring] } });
            return;
          }
        }
        lines.features.push(f);
      } else if (t === 'Polygon' || t === 'MultiPolygon') polygons.features.push(f);
    });

    if (lines.features.length) addNewLayer(lines, 'track', filename + ' — tracks');
    if (points.features.length) addNewLayer(points, 'point', filename + ' — waypoints');
    if (polygons.features.length) addNewLayer(polygons, 'polygon', filename + ' — polygons');

    if (document.getElementById('autoZoom').checked){
      const group = L.featureGroup(window.state.layers.map(l => l.leafletLayer).filter(Boolean));
      if (group.getLayers().length) map.fitBounds(group.getBounds().pad(0.1));
    }
  }

  function isRingClosed(coords, tolerance=1e-6){
    if (!coords || coords.length < 3) return false;
    const a = coords[0], b = coords[coords.length-1];
    if (Math.abs(a[0]-b[0]) <= tolerance && Math.abs(a[1]-b[1]) <= tolerance) return true;
    return false;
  }
  function closeRing(coords){
    const ring = coords.slice();
    const a = ring[0], b = ring[ring.length-1];
    if (a[0] !== b[0] || a[1] !== b[1]) ring.push([a[0], a[1]]);
    return ring;
  }

  /* convert track to polygon */
  function convertTrackToPolygon(layerId){
    const layer = window.state.layers.find(l=>l.id===layerId);
    if (!layer || layer.type !== 'track') { alert('Layer bukan track'); return; }
    const simplify = document.getElementById('simplifyOnConvert').checked;
    const tolMeters = parseFloat(document.getElementById('simplifyTolerance').value || '0');
    const polygons = { type:'FeatureCollection', features:[] };
    layer.geojson.features.forEach(f=>{
      const g = f.geometry; if (!g) return;
      if (g.type === 'LineString'){
        let coords = g.coordinates.slice();
        if (!isRingClosed(coords)) coords = closeRing(coords);
        if (coords.length >= 4){
          if (simplify && tolMeters>0) coords = simplifyRDP(coords, tolMeters);
          if (!isRingClosed(coords)) coords.push([coords[0][0], coords[0][1]]);
          if (coords.length >= 4) polygons.features.push({ type:'Feature', properties: f.properties||{}, geometry: { type:'Polygon', coordinates: [coords] } });
        }
      } else if (g.type === 'MultiLineString'){
        g.coordinates.forEach(arr=>{
          let coords = arr.slice();
          if (!isRingClosed(coords)) coords = closeRing(coords);
          if (coords.length >= 4){
            if (simplify && tolMeters>0) coords = simplifyRDP(coords, tolMeters);
            if (!isRingClosed(coords)) coords.push([coords[0][0], coords[0][1]]);
            if (coords.length >= 4) polygons.features.push({ type:'Feature', properties: f.properties||{}, geometry: { type:'Polygon', coordinates: [coords] } });
          }
        });
      }
    });
    if (!polygons.features.length) { alert('Tidak ada track tertutup untuk dikonversi.'); return; }
    addNewLayer(polygons, 'polygon', layer.name + ' — converted polygons');
  }

  /* ====== Style modal ====== */
  const modalBackdrop = document.getElementById('modalBackdrop');
  const styleColor = document.getElementById('styleColor');
  const styleOpacity = document.getElementById('styleOpacity');
  const lineWidth = document.getElementById('lineWidth');
  const pointRadius = document.getElementById('pointRadius');
  let editingLayerId = null;

  function openStyleModal(layerId){
    const layer = window.state.layers.find(l=>l.id===layerId);
    if (!layer) return;
    editingLayerId = layerId;
    document.getElementById('modalTitle').textContent = 'Edit: ' + layer.name;
    styleColor.value = (layer.style && layer.style.color) ? rgbToHex(layer.style.color) : '#ff0000';
    styleOpacity.value = (typeof layer.style.opacity === 'number') ? layer.style.opacity : 1;
    lineWidth.value = (layer.style && layer.style.width) ? layer.style.width : 3;
    pointRadius.value = (layer.style && layer.style.radius) ? layer.style.radius : 6;
    document.getElementById('lineOptions').style.display = layer.type==='track' || layer.type==='polygon' ? 'flex' : 'none';
    document.getElementById('radiusOptions').style.display = layer.type==='point' ? 'flex' : 'none';
    modalBackdrop.style.display = 'flex'; modalBackdrop.setAttribute('aria-hidden','false');
  }
  document.getElementById('modalCancel').onclick = () => { modalBackdrop.style.display='none'; modalBackdrop.setAttribute('aria-hidden','true'); editingLayerId=null; };
  document.getElementById('modalSave').onclick = () => {
    if (!editingLayerId) return;
    const layer = window.state.layers.find(l=>l.id===editingLayerId);
    if (!layer) return;
    layer.style = layer.style || {};
    layer.style.color = styleColor.value;
    layer.style.opacity = parseFloat(styleOpacity.value);
    if (layer.type === 'track') layer.style.width = parseInt(lineWidth.value,10);
    if (layer.type === 'point') layer.style.radius = parseInt(pointRadius.value,10);
    rebuildAllLayers();
    modalBackdrop.style.display='none'; modalBackdrop.setAttribute('aria-hidden','true'); editingLayerId=null;
  };

  function rgbToHex(input){
    if (!input) return '#000000';
    if (input[0] === '#') return input;
    const m = input.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
    if (!m) return '#000000';
    const r = parseInt(m[1]), g = parseInt(m[2]), b = parseInt(m[3]);
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  }

  /* ====== Polygon stats using turf (area in Ha) ====== */
  // load turf & jspdf & leaflet-image dynamically before PDF
  function loadExternalForPDF(){
    if (window._pdfLibsLoaded) return window._pdfLibsLoaded;
    window._pdfLibsLoaded = new Promise((resolve,reject)=>{
      const urls = [
        'https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js',
        'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js',
        // leaflet-image (map -> canvas)
        'https://rawcdn.githack.com/mapbox/leaflet-image/gh-pages/leaflet-image.js'
      ];
      let loaded = 0;
      urls.forEach(u=>{
        const s = document.createElement('script');
        s.src = u;
        s.onload = ()=>{ loaded++; if (loaded===urls.length) resolve(); };
        s.onerror = ()=> reject(new Error('Failed to load ' + u));
        document.head.appendChild(s);
      });
    });
    return window._pdfLibsLoaded;
  }

  function generatePolygonStats(){
    const stats = [];
    if (!window.turf) return stats;
    window.state.layers.forEach(layer=>{
      if (layer.type === 'polygon'){
        layer.geojson.features.forEach((f, idx)=>{
          try {
            const area = turf.area(f)/10000.0;
            stats.push({ name: layer.name + (layer.geojson.features.length>1 ? ' #' + (idx+1) : ''), area });
          } catch(e){}
        });
      }
    });
    return stats;
  }

  /* ====== Grid (graticule) creation – returns GeoJSON for lines spaced by meters ====== */
  function buildGraticuleForBounds(bounds, spacingMeters){
    const minLng = bounds.getWest(), maxLng = bounds.getEast();
    const minLat = bounds.getSouth(), maxLat = bounds.getNorth();
    const meanLat = (minLat+maxLat)/2;
    const meterToDeg = 1 / (111320 * Math.cos(meanLat * Math.PI/180));
    const stepDeg = spacingMeters * meterToDeg;
    const feats = [];
    // vertical lines (lng varying)
    const startLng = Math.ceil(minLng/stepDeg)*stepDeg;
    for (let lng = startLng; lng <= maxLng; lng += stepDeg){
      feats.push({ type:'Feature', geometry: { type:'LineString', coordinates: [[lng, minLat], [lng, maxLat]] } });
    }
    // horizontal lines (lat varying)
    const startLat = Math.ceil(minLat/stepDeg)*stepDeg;
    for (let lat = startLat; lat <= maxLat; lat += stepDeg){
      feats.push({ type:'Feature', geometry: { type:'LineString', coordinates: [[minLng, lat], [maxLng, lat]] } });
    }
    return { type:'FeatureCollection', features: feats };
  }

  // graticule leaflet layer (update on moveend/zoomend)
  let graticuleLayer = null;
  function ensureGrid(){
    const b = map.getBounds();
    const grid = buildGraticuleForBounds(b, 250);
    if (!graticuleLayer) {
      graticuleLayer = L.geoJSON(grid, { style: { color: '#666', weight: 0.6, opacity: 0.6 } }).addTo(map);
    } else {
      graticuleLayer.clearLayers();
      L.geoJSON(grid, { style: { color: '#666', weight: 0.6, opacity: 0.6 } }).eachLayer(l => graticuleLayer.addLayer(l));
    }
    // compute grid labels positions for drawing on canvas later
    window._gridLabels = computeGridLabels(map, b, 250);
  }
  map.on('moveend', ensureGrid);
  map.on('zoomend', ensureGrid);
  ensureGrid();

  // compute grid label positions (screen pixels) to draw later on canvas
  function computeGridLabels(map, bounds, spacingMeters){
    const labels = [];
    const minLng = bounds.getWest(), maxLng = bounds.getEast();
    const minLat = bounds.getSouth(), maxLat = bounds.getNorth();
    const meanLat = (minLat+maxLat)/2;
    const meterToDeg = 1 / (111320 * Math.cos(meanLat * Math.PI/180));
    const stepDeg = spacingMeters * meterToDeg;
    const startLng = Math.ceil(minLng/stepDeg)*stepDeg;
    for (let lng = startLng; lng <= maxLng; lng += stepDeg){
      const p = map.latLngToContainerPoint([bounds.getNorth(), lng]);
      labels.push({ x: p.x, y: Math.max(8, p.y-6), text: lng.toFixed(5) });
    }
    const startLat = Math.ceil(minLat/stepDeg)*stepDeg;
    for (let lat = startLat; lat <= maxLat; lat += stepDeg){
      const p = map.latLngToContainerPoint([lat, bounds.getWest()]);
      labels.push({ x: Math.max(6, p.x+2), y: p.y, text: lat.toFixed(5) });
    }
    return labels;
  }

  /* ====== PDF generation: use leaflet-image to render map to canvas, then compose overlays and jsPDF ====== */
  async function captureMapCanvasWithOverlays() {
    await loadExternalForPDF();
  
    return new Promise((resolve, reject) => {
      leafletImage(map, function (err, canvas) {
        if (err) { reject(err); return; }
  
        const dpr = window.devicePixelRatio || 1;
        const w = canvas.width;
        const h = canvas.height;
  
        const out = document.createElement('canvas');
        out.width = w;
        out.height = h;
        const ctx = out.getContext('2d');
  
        // ===== Draw Map =====
        ctx.drawImage(canvas, 0, 0, w, h);
  
        // ===== North Arrow (fixed corner) =====
        const NA_SIZE = 60 * dpr;
        const_margin = 20 * dpr;
        const x = w - NA_SIZE - _margin;
        const y = _margin;
  
        ctx.save();
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.fillRect(x - 6, y - 6, NA_SIZE + 12, NA_SIZE + 12);
  
        ctx.beginPath();
        ctx.moveTo(x + NA_SIZE / 2, y);
        ctx.lineTo(x, y + NA_SIZE);
        ctx.lineTo(x + NA_SIZE, y + NA_SIZE);
        ctx.closePath();
        ctx.fillStyle = '#000';
        ctx.fill();
  
        ctx.fillStyle = '#fff';
        ctx.font = `${20 * dpr}px Arial`;
        ctx.textAlign = "center";
        ctx.fillText("N", x + NA_SIZE / 2, y + NA_SIZE / 2 - 5 * dpr);
        ctx.restore();
  
        // ===== Scale Bar =====
        const scaleInfo = computeScaleForCanvas(map, w / dpr, h / dpr);
        const PX = Math.round(scaleInfo.pixelLen * dpr);
  
        const sbw = PX;
        const sbh = 10 * dpr;
        const sbx = 40 * dpr;
        const sby = h - 60 * dpr;
  
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.fillRect(sbx - 8, sby - 22, sbw + 16, sbh + 30);
  
        ctx.fillStyle = '#000';
        ctx.fillRect(sbx, sby, sbw, sbh);
  
        ctx.font = `${18 * dpr}px Arial`;
        ctx.textAlign = "left";
        ctx.fillText(scaleInfo.label, sbx, sby - 10 * dpr);
  
        // ===== GRID LABELS =====
        if (window._gridLabels) {
          ctx.font = `${14 * dpr}px Arial`;
          window._gridLabels.forEach(lbl => {
            ctx.fillStyle = "rgba(255,255,255,0.85)";
            ctx.fillRect(lbl.x * dpr - 4, lbl.y * dpr - 12, 70, 18);
  
            ctx.fillStyle = "#000";
            ctx.fillText(lbl.text, lbl.x * dpr, lbl.y * dpr);
          });
        }
  
        resolve(out.toDataURL('image/png'));
      });
    });
  }

  // compute scale for container width in px — similar approach as before
  function computeScaleForCanvas(map, canvasWpx, canvasHpx){
    const refPx = 100;
    const h = map.getSize().y;
    const p1 = map.containerPointToLatLng([0, h/2]);
    const p2 = map.containerPointToLatLng([refPx, h/2]);
    const meters = haversine(p1.lng, p1.lat, p2.lng, p2.lat);
    const nice = [1,2,5,10,20,50,100,200,500,1000,2000,5000,10000];
    let best = nice[0];
    for (let n of nice){ if (meters < n){ best = n; break; } best = n; }
    const pixelLen = refPx * (best / meters);
    return { pixelLen, label: best < 1000 ? `${best} m` : `${(best/1000).toFixed(2)} km`, valueMeters: best };
  }

  // haversine
  function haversine(lon1,lat1,lon2,lat2){
    const R = 6371000;
    const toRad = Math.PI/180;
    const dLat = (lat2-lat1)*toRad;
    const dLon = (lon2-lon1)*toRad;
    const a = Math.sin(dLat/2)*Math.sin(dLat/2) + Math.cos(lat1*toRad)*Math.cos(lat2*toRad)*Math.sin(dLon/2)*Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  }

  // Generate PDF A4 landscape: left map (68%), right legend & areas
  async function generatePDF() {
    await loadExternalForPDF();
    ensureGrid();
  
    await new Promise(r => setTimeout(r, 300));
    const imgData = await captureMapCanvasWithOverlays();
  
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF("landscape", "mm", "a4");
  
    const pw = pdf.internal.pageSize.getWidth();
    const ph = pdf.internal.pageSize.getHeight();
  
    // ==== MAP AREA (LEFT) ====
    const mapW = pw * 0.70;
    const mapH = ph - 30;
  
    pdf.addImage(imgData, "PNG", 10, 10, mapW, mapH);
  
    // ==== TITLE ====
    pdf.setFont("Arial", "bold");
    pdf.setFontSize(18);
    pdf.text("PETA AREAL PERKEBUNAN", 10, ph - 8);
  
    // ==== LEGEND (RIGHT COLUMN) ====
    pdf.setFont("Arial", "bold");
    pdf.setFontSize(14);
    pdf.text("Legenda", mapW + 20, 14);
  
    pdf.setFont("Arial", "normal");
    pdf.setFontSize(11);
  
    let y = 24;
  
    window.state.layers.forEach(layer => {
      pdf.setFont("Arial", "bold");
      pdf.setFontSize(12);
  
      // color box
      pdf.setFillColor(layer.style.color || "#000000");
      pdf.rect(mapW + 20, y - 4, 10, 5, "F");
  
      // text
      pdf.text(` ${layer.name}`, mapW + 35, y);
  
      y += 8;
    });
  
    // ==== AREA SUMMARY (IF ANY POLYGON) ====
    const stats = generatePolygonStats();
  
    if (stats.length) {
      pdf.setFont("Arial", "bold");
      pdf.setFontSize(14);
      pdf.text("Luas Blok (Ha)", mapW + 20, y + 6);
  
      y += 14;
      pdf.setFontSize(12);
  
      stats.forEach(s => {
        pdf.text(`${s.name}: ${s.area.toFixed(2)} Ha`, mapW + 20, y);
        y += 7;
      });
    }
  
    pdf.save("map_export.pdf");
  }

  // hook print button
  document.getElementById('printMapBtn').onclick = generatePDF;

  /* ====== small helpers ====== */
  function generateId(){ return 'id' + Math.random().toString(36).slice(2,9); }

  /* ====== Init UI actions already bound earlier to functions that exist; refresh UI initial state ====== */
  refreshLayerList(); refreshLegend();

  </script>
</body>
</html>
